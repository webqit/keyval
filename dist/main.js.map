{
  "version": 3,
  "sources": ["../src/KV.js", "../src/CookieStoreKV.js", "../src/IndexedDBKV.js", "../src/InMemoryKV.js", "../src/WebStorageKV.js", "../src/index.browser.js"],
  "sourcesContent": ["export class KV {\n\n    static create(options) { return new this(options); }\n\n    #path;\n    #ttl;\n    #registry;\n    #origins;\n    #options;\n    #fireHook;\n    #serializeHook;\n    #deserializeHook;\n\n    get path() { return this.#path; }\n    get ttl() { return this.#ttl; }\n    get hasTTL() { return this.#ttl !== null; }\n    get registry() { return this.#registry; }\n    get origins() { return this.#origins; }\n    get options() { return this.#options; }\n    get fieldLevelExpiry() { return true; }\n\n    constructor({ path, ttl = null, registry = new Map, origins = [], fireHook = null, serializeHook = null, deserializeHook = null, ...options } = {}) {\n        if (!Array.isArray(path)) {\n            throw new Error('Path must be an array if provided');\n        }\n        this.#path = path;\n        if (ttl !== null && typeof ttl !== 'number') {\n            throw new Error('TTL must be a number (in milliseconds) if provided; null otherwise');\n        }\n        this.#ttl = ttl;\n        if (!(registry instanceof Map)) {\n            throw new Error('Registry must be an instance of Map if provided');\n        }\n        this.#registry = registry;\n        if (!Array.isArray(origins)) {\n            throw new Error('Origins must be an array if provided');\n        }\n        this.#origins = origins;\n        this.#options = options;\n        if (fireHook && typeof fireHook !== 'function') {\n            throw new Error('fireHook must be a function if provided');\n        }\n        this.#fireHook = fireHook;\n        if (serializeHook && typeof serializeHook !== 'function') {\n            throw new Error('serializeHook must be a function if provided');\n        }\n        this.#serializeHook = serializeHook || ((val, ...args) => (val === undefined ? null : JSON.stringify(val, ...args)));\n        if (deserializeHook && typeof deserializeHook !== 'function') {\n            throw new Error('deserializeHook must be a function if provided');\n        }\n        this.#deserializeHook = deserializeHook || ((val) => (val === null ? undefined : JSON.parse(val)));\n    }\n\n    _serialize(val, ...args) { return this.#serializeHook(val, ...args); }\n    _deserialize(val) { return this.#deserializeHook(val); }\n\n    _path(path, create = true) {\n        if (!Array.isArray(path)) {\n            throw new Error(`Path length cannot be 0`);\n        }\n        /*\n        base -> {\n            subtree: uuid -> {\n                    subtree: field -> {\n                            subtree,\n                            entries: Set<fn>\n                        },\n                    entries: Set<fn>\n                },\n            entries: Set<fn>\n        }\n        */\n        return path.reduce((node, key, i) => {\n            if (create && !node?.subtree.has(key)) {\n                const subtree = new Map;\n                const entries = new Set;\n                const dispose = () => {\n                    node.subtree.delete(key);\n                    if (!node.subtree.size && !node.entries?.size) {\n                        //node.dispose?.();\n                    }\n                };\n                node.subtree.set(key, { subtree, entries, context: node, dispose });\n            }\n            if (create === 0 && !node?.subtree.has(key)) {\n                return node;\n            }\n            return node?.subtree.get(key);\n        }, { subtree: this.#registry, entries: new Set });\n    }\n\n    _subscribe(path, callback, options = {}) {\n        const node = this._path(path, true);\n\n        const dispose = () => {\n            node.entries.delete(subscription);\n            if (!node.entries.size) {\n                node.dispose();\n            }\n        };\n\n        const subscription = { callback, options, origins: this.#origins, dispose };\n        node.entries.add(subscription);\n\n        if (options.signal) {\n            options.signal.addEventListener('abort', dispose);\n        }\n\n        return dispose;\n    }\n\n    async _fire({ path = this.#path, origins = this.#origins, timestamp = Date.now(), ...event }) {\n        if (!['set', 'delete', 'clear', 'patch'].includes(event.type)) {\n            throw new Error(`Invalid event`);\n        }\n        const node = this._path(event.key ? path.concat(event.key) : path, 0);\n        if (!node) return;\n\n        const entries = [];\n        let _node = node;\n        do {\n            entries.push(..._node.entries);\n        } while ((_node = _node.context) && _node.entries);\n\n        const returnValues = [];\n        const fire = (subscription, _event = event) => {\n            const { callback, options, origins: subscriptionOrigins, dispose } = subscription;\n\n            let i = origins.length - 1;\n            for (; i >= (options.scope || 0); i--) {\n                if (subscriptionOrigins[i] !== origins[i]) return;\n            }\n\n            returnValues.push(callback({ ..._event, path, scope: i + 1, origins, timestamp }));\n\n            if (options.once) dispose();\n        };\n\n        entries.forEach((subscription) => fire(subscription));\n\n        if (event.type === 'clear' || event.type === 'patch') {\n            const node = this._path(path, false);\n            for (const [key, _node] of node?.subtree.entries() || []) {\n\n                let _event = { type: 'delete', key, detail: event.detail };\n                if (event.type === 'patch' && event.data && typeof event.data === 'object') {\n                    if (key in event.data) {\n                        _event = { type: 'set', key, value: event.data[key], detail: event.detail };\n                    } else if (!event.replace) {\n                        continue;\n                    }\n                }\n\n                for (const subscription of _node.entries) {\n                    fire(subscription, _event);\n                }\n            }\n        }\n\n        if (this.#fireHook) {\n            returnValues.push(this.#fireHook({ path, origins, timestamp, ...event }));\n        }\n\n        await Promise.all(returnValues);\n    }\n\n    _normalizeExpires(expires) {\n        if (!(expires ?? false)) return;\n\n        // Date instance\n        if (expires instanceof Date) {\n            return expires.getTime();\n        }\n\n        // Numeric timestamp (seconds or ms)\n        if (typeof expires === 'number') {\n            // Heuristic: seconds are too small to be ms\n            return expires < 1e12\n                ? expires * 1000\n                : expires;\n        }\n\n        // ISO date string\n        if (typeof expires === 'string') {\n            const ts = Date.parse(expires);\n            if (!Number.isNaN(ts)) return ts;\n        }\n\n        throw new TypeError(`Invalid expires value: ${expires}`);\n    }\n\n    _expired(node) {\n        if (!this.hasTTL || !this.fieldLevelExpiry) return false;\n        return !!(node?.expires && node.expires <= Date.now());\n    }\n\n    _resolveSet(key, value, options) {\n        const isSelector = typeof key === 'object' && key;\n        let rest;\n        ({ key, value, ...rest } = isSelector ? key : { key, value });\n        if (this.hasTTL && this.fieldLevelExpiry) {\n            if (!rest.expires) {\n                // Auto-derived from top-level TTL\n                rest.expires = Date.now() + this.ttl;\n            } else {\n                // Normalize expires\n                rest.expires = this._normalizeExpires(rest.expires);\n            }\n        }\n\n        const event = {\n            type: 'set',\n            key,\n            value,\n            path: this.path,\n            detail: options?.detail,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        return { key, value, rest, event };\n    }\n\n    _resolveInputPatch(obj, options) {\n        if (typeof obj !== 'object') {\n            throw new Error(`Argument must be a valid JSON object`);\n        }\n\n        const expires = this.hasTTL && this.fieldLevelExpiry ? Date.now() + this.ttl : null;\n        const plainData = {};\n        const data = {};\n        for (const [key, value] of Object.entries(obj)) {\n            if (options.meta && !(value && typeof value === 'object')) {\n                throw new Error(`A hash expected for field ${key}`);\n            }\n            plainData[key] = options.meta ? value.value : value;\n            data[key] = options.meta ? value : { value };\n            if (expires && !data[key].expires) {\n                // Auto-derived from top-level TTL\n                data[key].expires = expires;\n            } else if (this.hasTTL && this.fieldLevelExpiry && data[key].expires) {\n                // Normalize expires\n                data[key].expires = this._normalizeExpires(data[key].expires);\n            }\n        }\n\n        const event = {\n            type: 'patch',\n            data: plainData,\n            meta: !!options?.meta,\n            replace: !!options?.replace,\n            detail: options?.detail,\n            path: this.path,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        return { data, event };\n    }\n\n    _resolveDelete(key, options) {\n        key = typeof key === 'object' && key ? key.key : key;\n\n        const event = {\n            type: 'delete',\n            key,\n            path: this.path,\n            detail: options?.detail,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        return { key, event };\n    }\n\n    _resolveClear(options) {\n        const event = {\n            type: 'clear',\n            path: this.path,\n            detail: options?.detail,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        return { event };\n    }\n\n    // ----------\n\n    subscribe(key, callback, options = {}) {\n        if (typeof key === 'function') {\n            options = callback || {};\n            callback = key;\n            key = [];\n        }\n        const fieldPath = this.#path.concat(key);\n        return this._subscribe(fieldPath, callback, options);\n    }\n\n    cleanup() { this._path(this.#path, false)?.dispose(); }\n\n    async close() { }\n}", "import { KV } from './KV.js';\nexport { KV };\n\nexport class CookieStoreKV extends KV {\n\n    #storage;\n    #prefix;\n    #channel;\n    #cookiePath;\n\n    constructor({\n        storage = null,\n        channel = null,\n        cookiePath = '/',\n        ...options\n    } = {}) {\n        super(options);\n        if (!storage && typeof cookieStore === 'undefined') {\n            throw new Error(`cookieStore is not available in this environment`);\n        }\n        this.#storage = storage || cookieStore;\n        this.#prefix = this.path.join(':');\n        this.#cookiePath = cookiePath;\n        if (channel) {\n            this.#channel = new BroadcastChannel(channel);\n        }\n    }\n\n    #fullKey(key) { return `${this.#prefix}:${key}`; }\n\n    #ownsCookieName(name) { return name?.startsWith(this.#prefix + ':'); }\n\n    async #access(c, deserialize = true) {\n        if (typeof c === 'string') {\n            c = await this.#storage.get(c);\n        }\n        if (!c) return;\n        if (this._expired(c)) {\n            // Best-effort cleanup\n            await this.#storage.delete(c.name, { path: this.#cookiePath }).catch(() => { });\n            return;\n        }\n        if (deserialize) {\n            c.value = this._deserialize(c.value);\n        }\n        return c;\n    }\n\n    /* ---------- public API ---------- */\n\n    async close() {\n        this.#channel?.close();\n        await super.close();\n    }\n\n    async count() { return (await this.keys()).length; }\n\n    async keys() { return (await this.#entries()).map(([k]) => k); }\n\n    async values() { return (await this.#entries()).map(([, v]) => v); }\n\n    async entries() { return await this.#entries(); }\n\n    async json({ meta = false } = {}) { return Object.fromEntries(await this.#entries({ meta })); }\n\n    async #entries({ meta = false } = {}) {\n        const cookies = await this.#storage.getAll();\n        const out = [];\n\n        for (let c of cookies) {\n            if (!this.#ownsCookieName(c.name)\n                || !(c = await this.#access(c))) continue;\n            const key = c.name.slice(this.#prefix.length + 1);\n            delete c.name;\n            out.push([key, meta ? c : c.value]);\n        }\n\n        return out;\n    }\n\n    async has(key) {\n        key = typeof key === 'object' && key ? key.key : key;\n\n        if (!await this.#access(this.#fullKey(key), false)) return false;\n        return true;\n    }\n\n    async get(key) {\n        const isSelector = typeof key === 'object' && key;\n        key = isSelector ? key.key : key;\n\n        const c = await this.#access(this.#fullKey(key));\n        if (!c) return;\n\n        delete c.name;\n        return isSelector ? c : c.value;\n    }\n\n    async set(key, value, options = {}) {\n        let rest, event;\n        ({ key, value, rest, event } = this._resolveSet(key, value, options));\n\n        await this.#storage.set({\n            path: this.#cookiePath,\n            ...rest,\n            name: this.#fullKey(key),\n            value: this._serialize(value),\n        });\n\n        this.#channel?.postMessage(event);\n        await this._fire(event);\n    }\n\n    async patch(obj = null, options = {}) {\n        const { data, event } = this._resolveInputPatch(obj, options);\n\n        if (options.replace) {\n            const cookies = await this.#storage.getAll();\n            for (const c of cookies) {\n                if (this.#ownsCookieName(c.name)) {\n                    await this.#storage.delete(c.name, { path: this.#cookiePath }).catch(() => { });\n                }\n            }\n        }\n\n        for (const [key, { value, ...rest }] of Object.entries(data)) {\n            await this.#storage.set({\n                path: this.#cookiePath,\n                ...rest,\n                name: this.#fullKey(key),\n                value: this._serialize(value),\n            });\n        }\n\n        this.#channel?.postMessage(event);\n        await this._fire(event);\n    }\n\n    async delete(key, options = {}) {\n        let event;\n        ({ key, event } = this._resolveDelete(key, options));\n\n        await this.#storage.delete(this.#fullKey(key), { path: this.#cookiePath });\n\n        this.#channel?.postMessage(event);\n        await this._fire(event);\n    }\n\n    async clear(options = {}) {\n        const { event } = this._resolveClear(options);\n\n        const cookies = await this.#storage.getAll();\n        for (const c of cookies) {\n            if (this.#ownsCookieName(c.name)) {\n                await this.#storage.delete(c.name, { path: this.#cookiePath }).catch(() => { });\n            }\n        }\n\n        this.#channel?.postMessage(event);\n        await this._fire(event);\n    }\n}\n", "import { KV } from './KV.js';\nexport { KV };\n\nexport class IndexedDBKV extends KV {\n\n    static #dbCache = new Map;\n\n    #db;\n    #dbName;\n    #storeName;\n    #channel;\n\n    constructor({ dbName = 'webqit_keyval', channel = null, ...options }) {\n        super(options);\n        this.#dbName = dbName;\n        this.#storeName = this.path.join(':');\n        if (channel) {\n            this.#channel = new BroadcastChannel(channel);\n        }\n    }\n\n    /* ---------- internal helpers ---------- */\n\n    #attachDBLifecycle(db) {\n        db.onversionchange = () => {\n            // Another tab wants to upgrade the DB\n            db.close();\n\n            // Invalidate local handle so next op reopens\n            IndexedDBKV.#dbCache.delete(this.#dbName);\n\n            this.#db = null;\n        };\n    }\n\n    async #open() {\n        const cacheKey = this.#dbName;\n\n        if (IndexedDBKV.#dbCache.has(cacheKey)) {\n            this.#db = IndexedDBKV.#dbCache.get(cacheKey);\n            if (this.#db.objectStoreNames.contains(this.#storeName)) {\n                return this.#db;\n            }\n            // store missing \u2192 upgrade required\n        }\n\n        const openWithUpgrade = async (version) => {\n            return new Promise((resolve, reject) => {\n                const req = indexedDB.open(this.#dbName, version);\n\n                req.onupgradeneeded = () => {\n                    const db = req.result;\n                    if (!db.objectStoreNames.contains(this.#storeName)) {\n                        db.createObjectStore(this.#storeName);\n                    }\n                };\n\n                req.onsuccess = () => resolve(req.result);\n                req.onerror = () => reject(req.error);\n            });\n        };\n\n        // First open: get current version\n        const initialDB = await new Promise((resolve, reject) => {\n            const req = indexedDB.open(this.#dbName);\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = () => reject(req.error);\n        });\n\n        if (!initialDB.objectStoreNames.contains(this.#storeName)) {\n            const nextVersion = initialDB.version + 1;\n            initialDB.close();\n            this.#db = await openWithUpgrade(nextVersion);\n        } else {\n            this.#db = initialDB;\n        }\n\n        IndexedDBKV.#dbCache.set(cacheKey, this.#db);\n        this.#attachDBLifecycle(this.#db);\n        return this.#db;\n    }\n\n    #tx(mode = 'readonly') {\n        return this.#db\n            .transaction(this.#storeName, mode)\n            .objectStore(this.#storeName);\n    }\n\n    /* ---------- public API ---------- */\n\n    async close() {\n        this.#channel?.close();\n        this.#db?.close();\n\n        IndexedDBKV.#dbCache.delete(this.#dbName);\n        this.#db = null;\n\n        await super.close();\n    }\n\n    async count() { return (await this.keys()).length; }\n\n    async keys() { return (await this.#entries()).map(([k]) => k); }\n\n    async values() { return (await this.#entries()).map(([, e]) => e); }\n\n    async entries() { return await this.#entries(); }\n\n    async json({ meta = false } = {}) {\n        return Object.fromEntries(await this.#entries({ meta }));\n    }\n\n    async #entries({ meta = false } = {}) {\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readonly');\n            const store = tx.objectStore(this.#storeName);\n\n            const valuesReq = store.getAll();\n            const keysReq = store.getAllKeys();\n\n            let values, keys, out = [], expired = [];\n\n            valuesReq.onsuccess = () => { values = valuesReq.result; };\n            keysReq.onsuccess = () => { keys = keysReq.result; };\n\n            tx.oncomplete = () => {\n                keys.forEach((k, i) => {\n                    const v = values[i];\n                    if (this._expired(v)) {\n                        expired.push(k);\n                    } else {\n                        out.push([k, meta ? v : v.value]);\n                    }\n                });\n                if (expired.length) {\n                    const tx = this.#db.transaction(this.#storeName, 'readwrite');\n                    const store = tx.objectStore(this.#storeName);\n                    expired.forEach((k) => store.delete(k));\n                    tx.oncomplete = () => resolve(out);\n                    tx.onerror = () => reject(tx.error);\n                } else {\n                    resolve(out);\n                }\n            };\n\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n\n    async has(key) {\n        key = typeof key === 'object' && key ? key.key : key;\n        return (await this.keys()).includes(key);\n    }\n\n    async get(key) {\n        const isSelector = typeof key === 'object' && key;\n        key = isSelector ? key.key : key;\n\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const req = this.#tx().get(key);\n            req.onsuccess = async () => {\n                const fieldNode = req.result;\n                if (!fieldNode || this._expired(fieldNode)) {\n                    if (fieldNode) {\n                        const tx = this.#db.transaction(this.#storeName, 'readwrite');\n                        const store = tx.objectStore(this.#storeName);\n                        store.delete(key);\n                        tx.oncomplete = () => resolve();\n                        tx.onerror = () => reject(tx.error);\n                    } else resolve();\n                } else {\n                    resolve(isSelector ? fieldNode : fieldNode.value);\n                }\n            };\n            req.onerror = () => reject(req.error);\n        });\n    }\n\n    async set(key, value, options = {}) {\n        let rest, event;\n        ({ key, value, rest, event } = this._resolveSet(key, value, options));\n\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readwrite');\n            const store = tx.objectStore(this.#storeName);\n            store.put({ value, ...rest }, key);\n\n            tx.oncomplete = async () => {\n                await this._fire(event);\n                this.#channel?.postMessage(event);\n                resolve();\n            };\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n\n    async patch(obj = null, options = {}) {\n        const { data, event } = this._resolveInputPatch(obj, options);\n\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readwrite');\n\n            const store = tx.objectStore(this.#storeName);\n            if (options.replace) {\n                store.clear();\n            }\n\n            for (const [key, value] of Object.entries(data)) {\n                store.put(value, key);\n            }\n\n            tx.oncomplete = async () => {\n                await this._fire(event);\n                this.#channel?.postMessage(event);\n                resolve();\n            };\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n\n    async delete(key, options = {}) {\n        let event;\n        ({ key, event } = this._resolveDelete(key, options));\n\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readwrite');\n            const store = tx.objectStore(this.#storeName);\n            store.delete(key);\n\n            tx.oncomplete = async () => {\n                await this._fire(event);\n                this.#channel?.postMessage(event);\n                resolve();\n            };\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n\n    async clear(options = {}) {\n        const { event } = this._resolveClear(options);\n\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readwrite');\n            const store = tx.objectStore(this.#storeName);\n            store.clear();\n\n            tx.oncomplete = async () => {\n                await this._fire(event);\n                this.#channel?.postMessage(event);\n                resolve();\n            };\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n}\n", "import { KV } from './KV.js';\nexport { KV };\n\nexport class InMemoryKV extends KV {\n\n    #touch(fieldNode) {\n        if (!fieldNode?.subtree.has('value')) return;\n        const expires = fieldNode.subtree.get('expires');\n        if (expires && expires <= Date.now()) {\n            this.#drop(fieldNode);\n            return;\n        }\n        return fieldNode;\n    }\n\n    #drop(fieldNode) {\n        if (fieldNode && !fieldNode.entries.size) {\n            fieldNode.dispose();\n        } else {\n            fieldNode?.subtree.clear();\n        }\n    }\n\n    /* ---------- public API ---------- */\n\n    async close() { }\n\n    async count() { return (await this.keys()).length; }\n\n    async keys() { return (await this.#entries()).map(([k]) => k); }\n\n    async values() { return (await this.#entries()).map(([, e]) => e); }\n\n    async entries() { return await this.#entries(); }\n\n    async json({ meta = false } = {}) {\n        return Object.fromEntries(await this.#entries({ meta }));\n    }\n\n    async #entries({ meta = false } = {}) {\n        return [...(this._path(this.path)?.subtree.entries() || [])]\n            .filter(([, fieldNode]) => this.#touch(fieldNode))\n            .map(([key, fieldNode]) => [key, meta ? Object.fromEntries(fieldNode.subtree) : fieldNode.subtree.get('value')]);\n    }\n\n    async has(key) {\n        key = typeof key === 'object' && key ? key.key : key;\n        const fieldPath = this.path.concat(key);\n        return !!this.#touch(this._path(fieldPath, false));\n    }\n\n    async get(key) {\n        const isSelector = typeof key === 'object' && key;\n        key = isSelector ? key.key : key;\n\n        const fieldPath = this.path.concat(key);\n        const fieldNode = this.#touch(this._path(fieldPath, false));\n        if (!fieldNode) return;\n\n        if (isSelector) return Object.fromEntries(fieldNode.subtree);\n        return fieldNode.subtree.get('value');\n    }\n\n    async set(key, value, options = {}) {\n        let rest, event;\n        ({ key, value, rest, event } = this._resolveSet(key, value, options));\n\n        const fieldPath = this.path.concat(key);\n        const fieldNode = this._path(fieldPath);\n        fieldNode.subtree.set('value', value);\n        Object.entries(rest).forEach(([k, v]) => fieldNode.subtree.set(k, v));\n\n        await this._fire(event);\n    }\n\n    async patch(obj = null, options = {}) {\n        const { data, event } = this._resolveInputPatch(obj, options);\n\n        if (options.replace) {\n            for (const fieldNode of this._path(this.path, false)?.subtree.values() || []) {\n                this.#drop(fieldNode);\n            }\n        }\n\n        for (const [key, value] of Object.entries(data)) {\n            const fieldPath = this.path.concat(key);\n            const fieldNode = this._path(fieldPath);\n            Object.entries(value).forEach(([k, v]) => fieldNode.subtree.set(k, v));\n        }\n\n        await this._fire(event);\n    }\n\n    async delete(key, options = {}) {\n        let event;\n        ({ key, event } = this._resolveDelete(key, options));\n\n        const fieldPath = this.path.concat(key);\n        const fieldNode = this._path(fieldPath, false);\n        this.#drop(fieldNode);\n\n        await this._fire(event);\n    }\n\n    async clear(options = {}) {\n        const { event } = this._resolveClear(options);\n\n        for (const fieldNode of this._path(this.path, false)?.subtree.values() || []) {\n            this.#drop(fieldNode);\n        }\n        await this._fire(event);\n    }\n}", "import { KV } from './KV.js';\nexport { KV };\n\nexport class WebStorageKV extends KV {\n\n    #storage;\n    #prefix;\n    #channel;\n\n    constructor({\n        storage = 'local',              // 'local' | 'session' | Storage instance\n        channel = null,\n        ...options\n    } = {}) {\n        super(options);\n        this.#storage =\n            typeof storage === 'string'\n                ? (storage === 'session' ? window.sessionStorage : window.localStorage)\n                : storage;\n        this.#prefix = this.path.join(':');\n        if (channel) {\n            this.#channel = new BroadcastChannel(channel);\n        }\n    }\n\n    #fullKey(key) { return `${this.#prefix}:${key}`; }\n\n    #ownsStorageKey(storageKey) { return storageKey?.startsWith(this.#prefix + ':'); }\n\n    #access(key) {\n        const fullKey = this.#fullKey(key);\n        const raw = this.#storage.getItem(fullKey);\n        if (raw == null) return;\n\n        let fieldNode;\n        try {\n            fieldNode = this._deserialize(raw);\n        } catch {\n            // Corrupt/unexpected value -> treat as absent\n            this.#storage.removeItem(fullKey);\n            return;\n        }\n\n        if (this._expired(fieldNode)) {\n            this.#storage.removeItem(fullKey);\n            return;\n        }\n\n        return fieldNode;\n    }\n\n    #saveNode(key, fieldNode) {\n        const fullKey = this.#fullKey(key);\n        this.#storage.setItem(fullKey, this._serialize(fieldNode));\n    }\n\n    /* ---------- public API ---------- */\n\n    async close() {\n        this.#channel?.close();\n        await super.close();\n    }\n\n    async count() { return (await this.keys()).length; }\n\n    async keys() { return (await this.#entries()).map(([k]) => k); }\n\n    async values() { return (await this.#entries()).map(([, v]) => v); }\n\n    async entries() { return await this.#entries(); }\n\n    async json({ meta = false } = {}) {\n        return Object.fromEntries(await this.#entries({ meta }));\n    }\n\n    async #entries({ meta = false } = {}) {\n        const out = [];\n        for (let i = 0; i < this.#storage.length; i++) {\n            const storageKey = this.#storage.key(i);\n            if (!this.#ownsStorageKey(storageKey)) continue;\n\n            const key = storageKey.slice(this.#prefix.length + 1);\n            const fieldNode = this.#access(key);\n            if (!fieldNode) continue;\n\n            out.push([key, meta ? fieldNode : fieldNode.value]);\n        }\n        return out;\n    }\n\n    async has(key) {\n        key = typeof key === 'object' && key ? key.key : key;\n        return !!this.#access(key);\n    }\n\n    async get(key) {\n        const isSelector = typeof key === 'object' && key;\n        key = isSelector ? key.key : key;\n\n        const fieldNode = this.#access(key);\n        if (!fieldNode) return;\n\n        return isSelector ? fieldNode : fieldNode.value;\n    }\n\n    async set(key, value, options = {}) {\n        let rest, event;\n        ({ key, value, rest, event } = this._resolveSet(key, value, options));\n\n        this.#saveNode(key, { value, ...rest });\n\n        // Fire events locally + across tabs\n        this.#channel?.postMessage(event);\n        await this._fire(event);\n    }\n\n    async patch(obj = null, options = {}) {\n        let { data, event } = this._resolveInputPatch(obj, options);\n\n        if (options.replace) {\n            for (let i = this.#storage.length - 1; i >= 0; i--) {\n                const k = this.#storage.key(i);\n                if (this.#ownsStorageKey(k)) {\n                    this.#storage.removeItem(k);\n                }\n            }\n        }\n\n        for (const [key, fieldNode] of Object.entries(data)) {\n            const storedNode = { ...fieldNode };\n            this.#saveNode(key, storedNode);\n        }\n\n        this.#channel?.postMessage(event);\n        await this._fire(event);\n    }\n\n    async delete(key, options = {}) {\n        let event;\n        ({ key, event } = this._resolveDelete(key, options));\n\n        this.#storage.removeItem(this.#fullKey(key));\n\n        this.#channel?.postMessage(event);\n        await this._fire(event);\n    }\n\n    async clear(options = {}) {\n        const { event } = this._resolveClear(options);\n\n        // Remove only keys within this KV path prefix\n        for (let i = this.#storage.length - 1; i >= 0; i--) {\n            const k = this.#storage.key(i);\n            if (this.#ownsStorageKey(k)) {\n                this.#storage.removeItem(k);\n            }\n        }\n\n        this.#channel?.postMessage(event);\n        await this._fire(event);\n    }\n}\n", "import { KV } from './KV.js';\nimport { CookieStoreKV } from './CookieStoreKV.js';\nimport { IndexedDBKV } from './IndexedDBKV.js';\nimport { InMemoryKV } from './InMemoryKV.js';\nimport { WebStorageKV } from './WebStorageKV.js';\n\nif (!globalThis.webqit) {\n    globalThis.webqit = {};\n}\n\nObject.assign(globalThis.webqit, {\n    KV,\n    CookieStoreKV,\n    IndexedDBKV,\n    InMemoryKV,\n    WebStorageKV,\n});"],
  "mappings": "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",
  "names": ["KV", "options", "#path", "#ttl", "#registry", "#origins", "#options", "#fireHook", "#serializeHook", "#deserializeHook", "path", "ttl", "registry", "origins", "fireHook", "serializeHook", "deserializeHook", "val", "args", "create", "node", "key", "i", "subtree", "entries", "dispose", "callback", "subscription", "timestamp", "event", "_node", "returnValues", "fire", "_event", "subscriptionOrigins", "expires", "ts", "value", "isSelector", "rest", "obj", "plainData", "data", "fieldPath", "CookieStoreKV", "KV", "#storage", "#prefix", "#channel", "#cookiePath", "storage", "channel", "cookiePath", "options", "#fullKey", "key", "#ownsCookieName", "name", "#access", "c", "deserialize", "#entries", "k", "v", "meta", "cookies", "out", "isSelector", "value", "rest", "event", "obj", "data", "IndexedDBKV", "_IndexedDBKV", "KV", "#dbCache", "#db", "#dbName", "#storeName", "#channel", "dbName", "channel", "options", "#attachDBLifecycle", "db", "#open", "cacheKey", "openWithUpgrade", "version", "resolve", "reject", "req", "initialDB", "nextVersion", "#tx", "mode", "#entries", "k", "e", "meta", "tx", "store", "valuesReq", "keysReq", "values", "keys", "out", "expired", "i", "v", "key", "isSelector", "fieldNode", "value", "rest", "event", "obj", "data", "InMemoryKV", "KV", "#touch", "fieldNode", "expires", "#drop", "#entries", "k", "e", "meta", "key", "fieldPath", "isSelector", "value", "options", "rest", "event", "v", "obj", "data", "WebStorageKV", "KV", "#storage", "#prefix", "#channel", "storage", "channel", "options", "#fullKey", "key", "#ownsStorageKey", "storageKey", "#access", "fullKey", "raw", "fieldNode", "#saveNode", "#entries", "k", "v", "meta", "out", "i", "isSelector", "value", "rest", "event", "obj", "data", "storedNode", "KV", "CookieStoreKV", "IndexedDBKV", "InMemoryKV", "WebStorageKV"]
}
