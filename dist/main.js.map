{
  "version": 3,
  "sources": ["../src/Store.js", "../src/MemoryStore.js"],
  "sourcesContent": ["export class Store {\n\n    static create(options) { return new this(options); }\n\n    #path;\n    #ttl;\n    #registry;\n    #origins;\n\n    get path() { return this.#path; }\n    get ttl() { return this.#ttl; }\n    get registry() { return this.#registry; }\n    get origins() { return this.#origins; }\n\n    constructor({ path, ttl = 0, registry = new Map, origins = [] } = {}) {\n        this.#path = path;\n        this.#ttl = ttl;\n        this.#registry = registry;\n        this.#origins = origins;\n    }\n\n    _path(path, create = true) {\n        if (!Array.isArray(path) || !path.length) {\n            throw new Error(`Path length cannot be 0`);\n        }\n        /*\n        base -> {\n            subtree: uuid -> {\n                    subtree: field -> {\n                            subtree,\n                            entries: Set<fn>\n                        },\n                    entries: Set<fn>\n                },\n            entries: Set<fn>\n        }\n        */\n        return path.reduce((node, key, i) => {\n            if (create && !node?.subtree.has(key)) {\n                const subtree = new Map;\n                const entries = new Set;\n                const dispose = () => {\n                    node.subtree.delete(key);\n                    if (!node.subtree.size && !node.entries?.size) {\n                        //node.dispose?.();\n                    }\n                };\n                node.subtree.set(key, { subtree, entries, context: node, dispose });\n            }\n            if (create === 0 && i && !node?.subtree.has(key)) {\n                return node;\n            }\n            return node?.subtree.get(key);\n        }, { subtree: this.#registry });\n    }\n\n    _observe(path, callback, options = {}) {\n        const node = this._path(path, true);\n\n        const dispose = () => {\n            node.entries.delete(subscription);\n            if (!node.entries.size) {\n                node.dispose();\n            }\n        };\n\n        const subscription = { callback, options, origins: this.#origins, dispose };\n        node.entries.add(subscription);\n\n        if (options.signal) {\n            options.signal.addEventListener('abort', dispose);\n        }\n\n        return dispose;\n    }\n\n    async _fire({ path = this.#path, origins = this.#origins, timestamp = Date.now(), ...event }) {\n        if (!['set', 'delete', 'clear', 'json'].includes(event.type)) {\n            throw new Error(`Invalid event`);\n        }\n        const node = this._path(event.key ? path.concat(event.key) : path, 0);\n        if (!node) return;\n\n        const entries = [];\n        let _node = node;\n        do {\n            entries.push(..._node.entries);\n        } while ((_node = _node.context) && _node.entries);\n\n        const returnValues = [];\n        const fire = (subscription, _event = event) => {\n            const { callback, options, origins: subscriptionOrigins, dispose } = subscription;\n\n            let i = this.#origins.length - 1;\n            for (; i >= (options.scope || 0); i--) {\n                if (subscriptionOrigins[i] !== this.#origins[i]) return;\n            }\n\n            returnValues.push(callback({ ..._event, path, scope: i + 1, origins, timestamp }));\n\n            if (options.once) dispose();\n        };\n\n        entries.forEach((subscription) => fire(subscription));\n\n        if (event.type === 'clear' || event.type === 'json') {\n            const node = this._path(path, false);\n            for (const [key, _node] of node?.subtree.entries() || []) {\n\n                let _event = { type: 'delete', key };\n                if (event.type === 'json' && event.data && typeof event.data === 'object') {\n                    if (key in event.data) {\n                        _event = { type: 'set', key, value: event.data[key] };\n                    } else if (event.options?.merge) {\n                        continue;\n                    }\n                }\n\n                for (const subscription of _node.entries) {\n                    fire(subscription, _event);\n                }\n            }\n        }\n\n        await Promise.all(returnValues);\n    }\n\n    // ----------\n\n    observe(key, callback, options = {}) {\n        if (typeof key === 'function') {\n            options = callback || {};\n            callback = key;\n            key = [];\n        }\n        const fieldPath = this.#path.concat(key);\n        return this._observe(fieldPath, callback, options);\n    }\n\n    cleanup() { this._path(this.#path, false)?.dispose(); }\n\n    async close() { }\n}", "import { Store } from './Store.js';\nexport { Store };\n\nexport class MemoryStore extends Store {\n\n    #exists(node) {\n        if (!node?.subtree.has('value')) return;\n        const expiresAt = node.subtree.get('expiresAt');\n        if (expiresAt && expiresAt <= Date.now()) {\n            this.#drop(node);\n            return;\n        }\n        return node;\n    }\n\n    #drop(node) {\n        if (node && !node.entries.size) {\n            node.dispose();\n        } else {\n            node?.subtree.clear();\n        }\n    }\n\n    async keys() {\n        return [...(this._path(this.path)?.subtree.entries() || [])]\n            .filter(([, node]) => this.#exists(node))\n            .map(([key]) => key);\n    }\n    \n    async values() {\n        return [...(this._path(this.path)?.subtree.values() || [])]\n            .filter((node) => this.#exists(node))\n            .map((node) => node.subtree.get('value'));\n    }\n    \n    async entries() { return await this.#entries(); }\n    \n    async #entries(dump = false) {\n        return [...(this._path(this.path)?.subtree.entries() || [])]\n            .filter(([, node]) => this.#exists(node))\n            .map(([key, node]) => [key, dump ? Object.fromEntries(node.subtree) : node.subtree.get('value')]);\n    }\n\n    async count() { return this.keys().then((k) => k.length); }\n\n    async has(key) {\n        const fieldPath = this.path.concat(key);\n        return !!this.#exists(this._path(fieldPath, false));\n    }\n\n    async get(key) {\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath, false);\n        return this.#exists(node)?.subtree.get('value');\n    }\n\n    async set(key, value) {\n        const event = {\n            type: 'set',\n            key,\n            value,\n        };\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath);\n        node.subtree.set('value', value);\n        if (this.ttl) {\n            node.subtree.set('expiresAt', Date.now() + this.ttl * 1000);\n        }\n        await this._fire(event);\n    }\n\n    async delete(key) {\n        const event = {\n            type: 'delete',\n            key,\n        };\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath, false);\n        this.#drop(node);\n        await this._fire(event);\n    }\n\n    async clear() {\n        const event = {\n            type: 'clear',\n        };\n        for (const node of this._path(this.path, false)?.subtree.values() || []) {\n            this.#drop(node);\n        }\n        await this._fire(event);\n    }\n\n    async json(arg = null, options = {}) {\n        if (arg && arg !== true) {\n            if (typeof arg !== 'object') {\n                throw new Error(`Argument must be a valid JSON object`);\n            }\n\n            const expiresAt = this.ttl ? Date.now() + this.ttl * 1000 : null;\n            const unhashed = {};\n            const data = {};\n            for (const [key, value] of Object.entries(arg)) {\n                if (options.hashed && !(value && typeof value === 'object')) {\n                    throw new Error(`A hash expected for field ${key}`);\n                }\n                unhashed[key] = options.hashed ? value.value : value;\n                data[key] = options.hashed\n                    ? { value: undefined, ...value, expiresAt }\n                    : { value, expiresAt };\n            }\n\n            const event = {\n                type: 'json',\n                data: unhashed,\n                options,\n                path: this.path,\n                origins: this.origins,\n                timestamp: Date.now(),\n            };\n\n            if (!options.merge) {\n                for (const node of this._path(this.path, false)?.subtree.values() || []) {\n                    this.#drop(node);\n                }\n            }\n\n            for (const [key, value] of Object.entries(data)) {\n                const fieldPath = this.path.concat(key);\n                const node = this._path(fieldPath);\n                node.subtree = new Map(Object.entries(value));\n            }\n\n            await this._fire(event);\n            return;\n        }\n\n        return Object.fromEntries(await this.#entries(arg));\n    }\n}"],
  "mappings": "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",
  "names": ["Store", "options", "#path", "#ttl", "#registry", "#origins", "path", "ttl", "registry", "origins", "create", "node", "key", "i", "subtree", "entries", "dispose", "callback", "subscription", "timestamp", "event", "_node", "returnValues", "fire", "_event", "subscriptionOrigins", "fieldPath", "MemoryStore", "Store", "#exists", "node", "expiresAt", "#drop", "key", "#entries", "dump", "k", "fieldPath", "value", "event", "arg", "options", "unhashed", "data"]
}
