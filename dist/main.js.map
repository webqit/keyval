{
  "version": 3,
  "sources": ["../src/KV.js", "../src/InMemoryKV.js"],
  "sourcesContent": ["export class KV {\n\n    static create(options) { return new this(options); }\n\n    #path;\n    #ttl;\n    #registry;\n    #origins;\n    #options;\n\n    get path() { return this.#path; }\n    get ttl() { return this.#ttl; }\n    get registry() { return this.#registry; }\n    get origins() { return this.#origins; }\n    get options() { return this.#options; }\n    get keyLevelExpires() { return true; }\n\n    constructor({ path, ttl = 0, registry = new Map, origins = [], ...options } = {}) {\n        this.#path = path;\n        this.#ttl = ttl;\n        this.#registry = registry;\n        this.#origins = origins;\n        this.#options = options;\n    }\n\n    _path(path, create = true) {\n        if (!Array.isArray(path) || !path.length) {\n            throw new Error(`Path length cannot be 0`);\n        }\n        /*\n        base -> {\n            subtree: uuid -> {\n                    subtree: field -> {\n                            subtree,\n                            entries: Set<fn>\n                        },\n                    entries: Set<fn>\n                },\n            entries: Set<fn>\n        }\n        */\n        return path.reduce((node, key, i) => {\n            if (create && !node?.subtree.has(key)) {\n                const subtree = new Map;\n                const entries = new Set;\n                const dispose = () => {\n                    node.subtree.delete(key);\n                    if (!node.subtree.size && !node.entries?.size) {\n                        //node.dispose?.();\n                    }\n                };\n                node.subtree.set(key, { subtree, entries, context: node, dispose });\n            }\n            if (create === 0 && i && !node?.subtree.has(key)) {\n                return node;\n            }\n            return node?.subtree.get(key);\n        }, { subtree: this.#registry });\n    }\n\n    _observe(path, callback, options = {}) {\n        const node = this._path(path, true);\n\n        const dispose = () => {\n            node.entries.delete(subscription);\n            if (!node.entries.size) {\n                node.dispose();\n            }\n        };\n\n        const subscription = { callback, options, origins: this.#origins, dispose };\n        node.entries.add(subscription);\n\n        if (options.signal) {\n            options.signal.addEventListener('abort', dispose);\n        }\n\n        return dispose;\n    }\n\n    async _fire({ path = this.#path, origins = this.#origins, timestamp = Date.now(), ...event }) {\n        if (!['set', 'delete', 'clear', 'json'].includes(event.type)) {\n            throw new Error(`Invalid event`);\n        }\n        const node = this._path(event.key ? path.concat(event.key) : path, 0);\n        if (!node) return;\n\n        const entries = [];\n        let _node = node;\n        do {\n            entries.push(..._node.entries);\n        } while ((_node = _node.context) && _node.entries);\n\n        const returnValues = [];\n        const fire = (subscription, _event = event) => {\n            const { callback, options, origins: subscriptionOrigins, dispose } = subscription;\n\n            let i = origins.length - 1;\n            for (; i >= (options.scope || 0); i--) {\n                if (subscriptionOrigins[i] !== origins[i]) return;\n            }\n\n            returnValues.push(callback({ ..._event, path, scope: i + 1, origins, timestamp }));\n\n            if (options.once) dispose();\n        };\n\n        entries.forEach((subscription) => fire(subscription));\n\n        if (event.type === 'clear' || event.type === 'json') {\n            const node = this._path(path, false);\n            for (const [key, _node] of node?.subtree.entries() || []) {\n\n                let _event = { type: 'delete', key };\n                if (event.type === 'json' && event.data && typeof event.data === 'object') {\n                    if (key in event.data) {\n                        _event = { type: 'set', key, value: event.data[key] };\n                    } else if (event.options?.merge) {\n                        continue;\n                    }\n                }\n\n                for (const subscription of _node.entries) {\n                    fire(subscription, _event);\n                }\n            }\n        }\n\n        await Promise.all(returnValues);\n    }\n\n    _normalizeExpires(expires) {\n        if (!(expires ?? false)) return;\n\n        // Date instance\n        if (expires instanceof Date) {\n            return expires.getTime();\n        }\n\n        // Numeric timestamp (seconds or ms)\n        if (typeof expires === 'number') {\n            // Heuristic: seconds are too small to be ms\n            return expires < 1e12\n                ? expires * 1000\n                : expires;\n        }\n\n        // ISO date string\n        if (typeof expires === 'string') {\n            const ts = Date.parse(expires);\n            if (!Number.isNaN(ts)) return ts;\n        }\n\n        throw new TypeError(`Invalid expires value: ${expires}`);\n    }\n\n    _expired(node) {\n        if (!this.ttl || !this.keyLevelExpires) return false;\n        return !!(node?.expires && node.expires <= Date.now());\n    }\n\n    _resolveSet(key, value) {\n        const isSelector = typeof key === 'object' && key;\n        let rest;\n        ({ key, value, ...rest } = isSelector ? key : { key, value });\n        if (this.ttl && this.keyLevelExpires) {\n            if (!rest.expires) {\n                // Auto-derived from top-level TTL\n                rest.expires = Date.now() + this.ttl;\n            } else {\n                // Normalize expires\n                rest.expires = this._normalizeExpires(rest.expires);\n            }\n        }\n\n        const event = {\n            type: 'set',\n            key,\n            value,\n            path: this.path,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        return { key, value, rest, event };\n    }\n\n    _resolveInputJson(arg, options) {\n        if (typeof arg !== 'object') {\n            throw new Error(`Argument must be a valid JSON object`);\n        }\n\n        const expires = this.ttl && this.keyLevelExpires ? Date.now() + this.ttl : null;\n        const unhashed = {};\n        const data = {};\n        for (const [key, value] of Object.entries(arg)) {\n            if (options.hashed && !(value && typeof value === 'object')) {\n                throw new Error(`A hash expected for field ${key}`);\n            }\n            unhashed[key] = options.hashed ? value.value : value;\n            data[key] = options.hashed ? value : { value };\n            if (expires && !data[key].expires) {\n                // Auto-derived from top-level TTL\n                data[key].expires = expires;\n            } else if (this.ttl && this.keyLevelExpires && data[key].expires) {\n                // Normalize expires\n                data[key].expires = this._normalizeExpires(data[key].expires);\n            }\n        }\n\n        const event = {\n            type: 'json',\n            data: unhashed,\n            options,\n            path: this.path,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        return { data, event };\n    }\n\n    // ----------\n\n    observe(key, callback, options = {}) {\n        if (typeof key === 'function') {\n            options = callback || {};\n            callback = key;\n            key = [];\n        }\n        const fieldPath = this.#path.concat(key);\n        return this._observe(fieldPath, callback, options);\n    }\n\n    cleanup() { this._path(this.#path, false)?.dispose(); }\n\n    async close() { }\n}", "import { KV } from './KV.js';\nexport { KV };\n\nexport class InMemoryKV extends KV {\n\n    #exists(node) {\n        if (!node?.subtree.has('value')) return;\n        const expires = node.subtree.get('expires');\n        if (expires && expires <= Date.now()) {\n            this.#drop(node);\n            return;\n        }\n        return node;\n    }\n\n    #drop(node) {\n        if (node && !node.entries.size) {\n            node.dispose();\n        } else {\n            node?.subtree.clear();\n        }\n    }\n\n    /* ---------- public API ---------- */\n\n    async close() { }\n\n    async count() { return (await this.keys()).length; }\n\n    async keys() { return (await this.#entries()).map(([k]) => k); }\n\n    async values() { return (await this.#entries()).map(([, e]) => e); }\n\n    async entries() { return await this.#entries(); }\n\n    async #entries(dump = false) {\n        return [...(this._path(this.path)?.subtree.entries() || [])]\n            .filter(([, node]) => this.#exists(node))\n            .map(([key, node]) => [key, dump ? Object.fromEntries(node.subtree) : node.subtree.get('value')]);\n    }\n\n    async has(key) {\n        key = typeof key === 'object' && key ? key.key : key;\n        const fieldPath = this.path.concat(key);\n        return !!this.#exists(this._path(fieldPath, false));\n    }\n\n    async get(key) {\n        const isSelector = typeof key === 'object' && key;\n        key = isSelector ? key.key : key;\n\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath, false);\n\n        if (isSelector) return Object.fromEntries(node.subtree);\n        return this.#exists(node)?.subtree.get('value');\n    }\n\n    async set(key, value) {\n        let rest, event;\n        ({ key, value, rest, event } = this._resolveSet(key, value));\n\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath);\n        node.subtree.set('value', value);\n        Object.entries(rest).forEach(([k, v]) => node.subtree.set(k, v));\n\n        await this._fire(event);\n    }\n\n    async delete(key) {\n        key = typeof key === 'object' && key ? key.key : key;\n\n        const event = {\n            type: 'delete',\n            key,\n        };\n\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath, false);\n        this.#drop(node);\n\n        await this._fire(event);\n    }\n\n    async clear() {\n        const event = { type: 'clear' };\n        for (const node of this._path(this.path, false)?.subtree.values() || []) {\n            this.#drop(node);\n        }\n        await this._fire(event);\n    }\n\n    async json(arg = null, options = {}) {\n        if (arg && arg !== true) {\n            const { data, event } = this._resolveInputJson(arg, options);\n\n            if (!options.merge) {\n                for (const node of this._path(this.path, false)?.subtree.values() || []) {\n                    this.#drop(node);\n                }\n            }\n\n            for (const [key, value] of Object.entries(data)) {\n                const fieldPath = this.path.concat(key);\n                const node = this._path(fieldPath);\n                Object.entries(value).forEach(([k, v]) => node.subtree.set(k, v));\n            }\n\n            await this._fire(event);\n            return;\n        }\n\n        return Object.fromEntries(await this.#entries(arg));\n    }\n}"],
  "mappings": "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",
  "names": ["KV", "options", "#path", "#ttl", "#registry", "#origins", "#options", "path", "ttl", "registry", "origins", "create", "node", "key", "subtree", "entries", "dispose", "callback", "subscription", "timestamp", "event", "_node", "returnValues", "fire", "_event", "subscriptionOrigins", "i", "expires", "ts", "value", "isSelector", "rest", "arg", "unhashed", "data", "fieldPath", "InMemoryKV", "KV", "#exists", "node", "expires", "#drop", "#entries", "k", "e", "dump", "key", "fieldPath", "isSelector", "value", "rest", "event", "v", "arg", "options", "data"]
}
