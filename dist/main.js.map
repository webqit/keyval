{
  "version": 3,
  "sources": ["../src/Store.js", "../src/MemoryStore.js"],
  "sourcesContent": ["export class Store {\n\n    static create(options) { return new this(options); }\n\n    #path;\n    #ttl;\n    #registry;\n    #origins;\n\n    get path() { return this.#path; }\n    get ttl() { return this.#ttl; }\n    get registry() { return this.#registry; }\n    get origins() { return this.#origins; }\n\n    constructor({ path, ttl = 0, registry = new Map, origins = [] } = {}) {\n        this.#path = path;\n        this.#ttl = ttl;\n        this.#registry = registry;\n        this.#origins = origins;\n    }\n\n    _path(path, create = true) {\n        if (!Array.isArray(path) || !path.length || path.length > this.#path.length + 1) {\n            throw new Error(`Path length must be between 1 and ${this.#path.length + 1}`);\n        }\n        /*\n        base -> {\n            subtree: uuid -> {\n                    subtree: field -> {\n                            subtree,\n                            entries: Set<fn>\n                        },\n                    entries: Set<fn>\n                },\n            entries: Set<fn>\n        }\n        */\n        return path.reduce((node, key, i) => {\n            if (create === 0 && i && !node.subtree.has(key)) {\n                return node;\n            }\n            if (create && !node.subtree.has(key)) {\n                const subtree = new Map;\n                const entries = new Set;\n                const dispose = () => node.subtree.delete(key);\n                node.subtree.set(key, { subtree, entries, context: node, dispose });\n            }\n            return node?.subtree.get(key);\n        }, { subtree: this.#registry });\n    }\n\n    _observe(path, callback, options = {}) {\n        const node = this._path(path, true);\n\n        const dispose = () => {\n            node.entries.delete(subscription);\n            if (!node.entries.size) {\n                node.dispose();\n            }\n        };\n\n        const subscription = { callback, options, origins: this.#origins, dispose };\n        node.entries.add(subscription);\n\n        if (options.signal) {\n            options.signal.addEventListener('abort', dispose);\n        }\n\n        return dispose;\n    }\n\n    async _fire({ path = this.#path, origins = this.#origins, timestamp = Date.now(), ...event }) {\n        if (!['set', 'delete', 'clear'].includes(event.type)) {\n            throw new Error(`Invalid event`);\n        }\n        const node = this._path(path, 0);\n        if (!node) return;\n\n        const entries = [];\n        let _node = node;\n        do {\n            entries.push(..._node.entries);\n        } while ((_node = _node.context) && _node.entries);\n\n        const returnValues = [];\n        const fire = (subscription, _path = path) => {\n            const { callback, options, origins: subscriptionOrigins, dispose } = subscription;\n\n            let i = this.#origins.length - 1;\n            for (; i >= (options.scope || 0); i--) {\n                if (subscriptionOrigins[i] !== this.#origins[i]) return;\n            }\n\n            returnValues.push(callback({ ...event, path: _path, scope: i + 1, origins, timestamp }));\n\n            if (options.once) dispose();\n        };\n\n        entries.forEach(fire);\n\n        if (event.type === 'clear') {\n            const node = this._path(path, false);\n            for (const [key, field] of node?.subtree.entries() || []) {\n                for (const subscription of field.entries) {\n                    fire(subscription, path.concat(key));\n                }\n            }\n        }\n\n        await Promise.all(returnValues);\n    }\n\n    // ----------\n\n    observe(key, callback, options = {}) {\n        if (typeof key === 'function') {\n            options = callback || {};\n            callback = key;\n            key = [];\n        }\n        const fieldPath = this.#path.concat(key);\n        return this._observe(fieldPath, callback, options);\n    }\n\n    cleanup() { this._path(this.#path, false)?.dispose(); }\n\n    async close() { }\n}", "import { Store } from './Store.js';\nexport { Store };\n\nexport class MemoryStore extends Store {\n\n    #exists(node) {\n        if (!node?.subtree.has('value')) return;\n        const expiresAt = node.subtree.get('expiresAt');\n        if (expiresAt && expiresAt <= Date.now()) {\n            node.subtree.clear();\n            return;\n        }\n        return node;\n    }\n\n    async keys() { return [...(this._path(this.path)?.subtree.entries() || [])].filter(([, node]) => this.#exists(node)).map(([key]) => key); }\n    async values() { return [...(this._path(this.path)?.subtree.values() || [])].filter((node) => this.#exists(node)).map((node) => node.subtree.get('value')); }\n    async entries() { return [...(this._path(this.path)?.subtree.entries() || [])].filter(([, node]) => this.#exists(node)).map(([key, node]) => [key, node.subtree.get('value')]); }\n    async count() { return this.keys().then((k) => k.length); }\n\n    async has(key) {\n        const fieldPath = this.path.concat(key);\n        return !!this.#exists(this._path(fieldPath, false));\n    }\n\n    async get(key) {\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath, false);\n        return this.#exists(node)?.subtree.get('value');\n    }\n\n    async getHash(key) {\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath, false);\n        return Object.fromEntries(this.#exists(node)?.subtree || []);\n    }\n\n    async set(key, value) {\n        const event = {\n            type: 'set',\n            key,\n            value,\n        };\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath);\n        node.subtree.set('value', value);\n        if (this.ttl) {\n            node.subtree.set('expiresAt', Date.now() + this.ttl * 1000);\n        }\n        await this._fire(event);\n    }\n\n    async setHash(key, { value, ...properties } = {}) {\n        const fieldPath = this.path.concat(key);\n        const node = this._path(fieldPath);\n        for (const k in properties) {\n            node.subtree.set(k, properties[k]);\n        }\n        return await this.set(key, value);\n    }\n\n    async delete(key) {\n        const event = {\n            type: 'delete',\n            key,\n        };\n        const fieldPath = this.path.concat(key);\n        this._path(fieldPath, false)?.subtree.clear();\n        await this._fire(event);\n    }\n\n    async clear() {\n        const event = {\n            type: 'clear',\n        };\n        for (const node of this._path(this.path, false)?.subtree.values() || []) {\n            node.subtree.clear();\n        }\n        await this._fire(event);\n    }\n}"],
  "mappings": "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",
  "names": ["Store", "options", "#path", "#ttl", "#registry", "#origins", "path", "ttl", "registry", "origins", "create", "node", "key", "subtree", "entries", "dispose", "callback", "subscription", "timestamp", "event", "_node", "returnValues", "fire", "_path", "subscriptionOrigins", "i", "field", "fieldPath", "MemoryStore", "Store", "#exists", "node", "expiresAt", "key", "k", "fieldPath", "value", "event", "properties"]
}
