(()=>{var m=class{static create(t){return new this(t)}#s;#e;#r;#t;#i;#o;#n;#a;get path(){return this.#s}get ttl(){return this.#e}get hasTTL(){return this.#e!==null}get registry(){return this.#r}get origins(){return this.#t}get options(){return this.#i}get fieldLevelExpiry(){return!0}constructor({path:t,ttl:e=null,registry:r=new Map,origins:s=[],fireHook:i=null,serializeHook:o=null,deserializeHook:n=null,...a}={}){if(!Array.isArray(t))throw new Error("Path must be an array if provided");if(this.#s=t,e!==null&&typeof e!="number")throw new Error("TTL must be a number (in milliseconds) if provided; null otherwise");if(this.#e=e,!(r instanceof Map))throw new Error("Registry must be an instance of Map if provided");if(this.#r=r,!Array.isArray(s))throw new Error("Origins must be an array if provided");if(this.#t=s,this.#i=a,i&&typeof i!="function")throw new Error("fireHook must be a function if provided");if(this.#o=i,o&&typeof o!="function")throw new Error("serializeHook must be a function if provided");if(this.#n=o||((c,...h)=>c===void 0?null:JSON.stringify(c,...h)),n&&typeof n!="function")throw new Error("deserializeHook must be a function if provided");this.#a=n||(c=>c===null?void 0:JSON.parse(c))}_serialize(t,...e){return this.#n(t,...e)}_deserialize(t){return this.#a(t)}_path(t,e=!0){if(!Array.isArray(t))throw new Error("Path length cannot be 0");return t.reduce((r,s,i)=>{if(e&&!r?.subtree.has(s)){let o=new Map,n=new Set,a=()=>{r.subtree.delete(s),!r.subtree.size&&r.entries?.size};r.subtree.set(s,{subtree:o,entries:n,context:r,dispose:a})}return e===0&&!r?.subtree.has(s)?r:r?.subtree.get(s)},{subtree:this.#r,entries:new Set})}_observe(t,e,r={}){let s=this._path(t,!0),i=()=>{s.entries.delete(o),s.entries.size||s.dispose()},o={callback:e,options:r,origins:this.#t,dispose:i};return s.entries.add(o),r.signal&&r.signal.addEventListener("abort",i),i}async _fire({path:t=this.#s,origins:e=this.#t,timestamp:r=Date.now(),...s}){if(!["set","delete","clear","patch"].includes(s.type))throw new Error("Invalid event");let i=this._path(s.key?t.concat(s.key):t,0);if(!i)return;let o=[],n=i;do o.push(...n.entries);while((n=n.context)&&n.entries);let a=[],c=(h,u=s)=>{let{callback:l,options:p,origins:f,dispose:y}=h,w=e.length-1;for(;w>=(p.scope||0);w--)if(f[w]!==e[w])return;a.push(l({...u,path:t,scope:w+1,origins:e,timestamp:r})),p.once&&y()};if(o.forEach(h=>c(h)),s.type==="clear"||s.type==="patch"){let h=this._path(t,!1);for(let[u,l]of h?.subtree.entries()||[]){let p={type:"delete",key:u,detail:s.detail};if(s.type==="patch"&&s.data&&typeof s.data=="object"){if(u in s.data)p={type:"set",key:u,value:s.data[u],detail:s.detail};else if(!s.replace)continue}for(let f of l.entries)c(f,p)}}this.#o&&a.push(this.#o({path:t,origins:e,timestamp:r,...s})),await Promise.all(a)}_normalizeExpires(t){if(t??!1){if(t instanceof Date)return t.getTime();if(typeof t=="number")return t<1e12?t*1e3:t;if(typeof t=="string"){let e=Date.parse(t);if(!Number.isNaN(e))return e}throw new TypeError(`Invalid expires value: ${t}`)}}_expired(t){return!this.hasTTL||!this.fieldLevelExpiry?!1:!!(t?.expires&&t.expires<=Date.now())}_resolveSet(t,e,r){let s=typeof t=="object"&&t,i;({key:t,value:e,...i}=s?t:{key:t,value:e}),this.hasTTL&&this.fieldLevelExpiry&&(i.expires?i.expires=this._normalizeExpires(i.expires):i.expires=Date.now()+this.ttl);let o={type:"set",key:t,value:e,path:this.path,detail:r?.detail,origins:this.origins,timestamp:Date.now()};return{key:t,value:e,rest:i,event:o}}_resolveInputPatch(t,e){if(typeof t!="object")throw new Error("Argument must be a valid JSON object");let r=this.hasTTL&&this.fieldLevelExpiry?Date.now()+this.ttl:null,s={},i={};for(let[n,a]of Object.entries(t)){if(e.meta&&!(a&&typeof a=="object"))throw new Error(`A hash expected for field ${n}`);s[n]=e.meta?a.value:a,i[n]=e.meta?a:{value:a},r&&!i[n].expires?i[n].expires=r:this.hasTTL&&this.fieldLevelExpiry&&i[n].expires&&(i[n].expires=this._normalizeExpires(i[n].expires))}let o={type:"patch",data:s,meta:!!e?.meta,replace:!!e?.replace,detail:e?.detail,path:this.path,origins:this.origins,timestamp:Date.now()};return{data:i,event:o}}_resolveDelete(t,e){t=typeof t=="object"&&t?t.key:t;let r={type:"delete",key:t,path:this.path,detail:e?.detail,origins:this.origins,timestamp:Date.now()};return{key:t,event:r}}_resolveClear(t){return{event:{type:"clear",path:this.path,detail:t?.detail,origins:this.origins,timestamp:Date.now()}}}observe(t,e,r={}){typeof t=="function"&&(r=e||{},e=t,t=[]);let s=this.#s.concat(t);return this._observe(s,e,r)}cleanup(){this._path(this.#s,!1)?.dispose()}async close(){}};var b=class d extends m{static#s=new Map;#e;#r;#t;#i;constructor({dbName:t="webqit_keyval",channel:e=null,...r}){super(r),this.#r=t,this.#t=this.path.join(":"),e&&(this.#i=new BroadcastChannel(e))}#o(t){t.onversionchange=()=>{t.close(),d.#s.delete(this.#r),this.#e=null}}async#n(){let t=this.#r;if(d.#s.has(t)&&(this.#e=d.#s.get(t),this.#e.objectStoreNames.contains(this.#t)))return this.#e;let e=async s=>new Promise((i,o)=>{let n=indexedDB.open(this.#r,s);n.onupgradeneeded=()=>{let a=n.result;a.objectStoreNames.contains(this.#t)||a.createObjectStore(this.#t)},n.onsuccess=()=>i(n.result),n.onerror=()=>o(n.error)}),r=await new Promise((s,i)=>{let o=indexedDB.open(this.#r);o.onsuccess=()=>s(o.result),o.onerror=()=>i(o.error)});if(r.objectStoreNames.contains(this.#t))this.#e=r;else{let s=r.version+1;r.close(),this.#e=await e(s)}return d.#s.set(t,this.#e),this.#o(this.#e),this.#e}#a(t="readonly"){return this.#e.transaction(this.#t,t).objectStore(this.#t)}async close(){this.#i?.close(),this.#e?.close(),d.#s.delete(this.#r),this.#e=null,await super.close()}async count(){return(await this.keys()).length}async keys(){return(await this.#c()).map(([t])=>t)}async values(){return(await this.#c()).map(([,t])=>t)}async entries(){return await this.#c()}async json({meta:t=!1}={}){return Object.fromEntries(await this.#c({meta:t}))}async#c({meta:t=!1}={}){return await this.#n(),new Promise((e,r)=>{let s=this.#e.transaction(this.#t,"readonly"),i=s.objectStore(this.#t),o=i.getAll(),n=i.getAllKeys(),a,c,h=[],u=[];o.onsuccess=()=>{a=o.result},n.onsuccess=()=>{c=n.result},s.oncomplete=()=>{if(c.forEach((l,p)=>{let f=a[p];this._expired(f)?u.push(l):h.push([l,t?f:f.value])}),u.length){let l=this.#e.transaction(this.#t,"readwrite"),p=l.objectStore(this.#t);u.forEach(f=>p.delete(f)),l.oncomplete=()=>e(h),l.onerror=()=>r(l.error)}else e(h)},s.onerror=()=>r(s.error)})}async has(t){return t=typeof t=="object"&&t?t.key:t,(await this.keys()).includes(t)}async get(t){let e=typeof t=="object"&&t;return t=e?t.key:t,await this.#n(),new Promise((r,s)=>{let i=this.#a().get(t);i.onsuccess=async()=>{let o=i.result;if(!o||this._expired(o))if(o){let n=this.#e.transaction(this.#t,"readwrite");n.objectStore(this.#t).delete(t),n.oncomplete=()=>r(),n.onerror=()=>s(n.error)}else r();else r(e?o:o.value)},i.onerror=()=>s(i.error)})}async set(t,e,r={}){let s,i;return{key:t,value:e,rest:s,event:i}=this._resolveSet(t,e,r),await this.#n(),new Promise((o,n)=>{let a=this.#e.transaction(this.#t,"readwrite");a.objectStore(this.#t).put({value:e,...s},t),a.oncomplete=async()=>{await this._fire(i),this.#i?.postMessage(i),o()},a.onerror=()=>n(a.error)})}async patch(t=null,e={}){let{data:r,event:s}=this._resolveInputPatch(t,e);return await this.#n(),new Promise((i,o)=>{let n=this.#e.transaction(this.#t,"readwrite"),a=n.objectStore(this.#t);e.replace&&a.clear();for(let[c,h]of Object.entries(r))a.put(h,c);n.oncomplete=async()=>{await this._fire(s),this.#i?.postMessage(s),i()},n.onerror=()=>o(n.error)})}async delete(t,e={}){let r;return{key:t,event:r}=this._resolveDelete(t,e),await this.#n(),new Promise((s,i)=>{let o=this.#e.transaction(this.#t,"readwrite");o.objectStore(this.#t).delete(t),o.oncomplete=async()=>{await this._fire(r),this.#i?.postMessage(r),s()},o.onerror=()=>i(o.error)})}async clear(t={}){let{event:e}=this._resolveClear(t);return await this.#n(),new Promise((r,s)=>{let i=this.#e.transaction(this.#t,"readwrite");i.objectStore(this.#t).clear(),i.oncomplete=async()=>{await this._fire(e),this.#i?.postMessage(e),r()},i.onerror=()=>s(i.error)})}};})();
//# sourceMappingURL=indexeddb.js.map
