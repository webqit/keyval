(()=>{var b=class{static create(e){return new this(e)}#s;#t;#r;#e;#i;#o;#n;#a;get path(){return this.#s}get ttl(){return this.#t}get hasTTL(){return this.#t!==null}get registry(){return this.#r}get origins(){return this.#e}get options(){return this.#i}get fieldLevelExpiry(){return!0}constructor({path:e,ttl:t=null,registry:r=new Map,origins:s=[],fireHook:i=null,serializeHook:o=null,deserializeHook:n=null,...a}={}){if(!Array.isArray(e))throw new Error("Path must be an array if provided");if(this.#s=e,t!==null&&typeof t!="number")throw new Error("TTL must be a number (in milliseconds) if provided; null otherwise");if(this.#t=t,!(r instanceof Map))throw new Error("Registry must be an instance of Map if provided");if(this.#r=r,!Array.isArray(s))throw new Error("Origins must be an array if provided");if(this.#e=s,this.#i=a,i&&typeof i!="function")throw new Error("fireHook must be a function if provided");if(this.#o=i,o&&typeof o!="function")throw new Error("serializeHook must be a function if provided");if(this.#n=o||((h,...c)=>h===void 0?null:JSON.stringify(h,...c)),n&&typeof n!="function")throw new Error("deserializeHook must be a function if provided");this.#a=n||(h=>h===null?void 0:JSON.parse(h))}_serialize(e,...t){return this.#n(e,...t)}_deserialize(e){return this.#a(e)}_path(e,t=!0){if(!Array.isArray(e))throw new Error("Path length cannot be 0");return e.reduce((r,s,i)=>{if(t&&!r?.subtree.has(s)){let o=new Map,n=new Set,a=()=>{r.subtree.delete(s),!r.subtree.size&&r.entries?.size};r.subtree.set(s,{subtree:o,entries:n,context:r,dispose:a})}return t===0&&!r?.subtree.has(s)?r:r?.subtree.get(s)},{subtree:this.#r,entries:new Set})}_observe(e,t,r={}){let s=this._path(e,!0),i=()=>{s.entries.delete(o),s.entries.size||s.dispose()},o={callback:t,options:r,origins:this.#e,dispose:i};return s.entries.add(o),r.signal&&r.signal.addEventListener("abort",i),i}async _fire({path:e=this.#s,origins:t=this.#e,timestamp:r=Date.now(),...s}){if(!["set","delete","clear","json"].includes(s.type))throw new Error("Invalid event");let i=this._path(s.key?e.concat(s.key):e,0);if(!i)return;let o=[],n=i;do o.push(...n.entries);while((n=n.context)&&n.entries);let a=[],h=(c,u=s)=>{let{callback:l,options:f,origins:p,dispose:y}=c,w=t.length-1;for(;w>=(f.scope||0);w--)if(p[w]!==t[w])return;a.push(l({...u,path:e,scope:w+1,origins:t,timestamp:r})),f.once&&y()};if(o.forEach(c=>h(c)),s.type==="clear"||s.type==="json"){let c=this._path(e,!1);for(let[u,l]of c?.subtree.entries()||[]){let f={type:"delete",key:u,detail:s.detail};if(s.type==="json"&&s.data&&typeof s.data=="object"){if(u in s.data)f={type:"set",key:u,value:s.data[u],detail:s.detail};else if(s.merge)continue}for(let p of l.entries)h(p,f)}}this.#o&&a.push(this.#o({path:e,origins:t,timestamp:r,...s})),await Promise.all(a)}_normalizeExpires(e){if(e??!1){if(e instanceof Date)return e.getTime();if(typeof e=="number")return e<1e12?e*1e3:e;if(typeof e=="string"){let t=Date.parse(e);if(!Number.isNaN(t))return t}throw new TypeError(`Invalid expires value: ${e}`)}}_expired(e){return!this.hasTTL||!this.fieldLevelExpiry?!1:!!(e?.expires&&e.expires<=Date.now())}_resolveSet(e,t,r){let s=typeof e=="object"&&e,i;({key:e,value:t,...i}=s?e:{key:e,value:t}),this.hasTTL&&this.fieldLevelExpiry&&(i.expires?i.expires=this._normalizeExpires(i.expires):i.expires=Date.now()+this.ttl);let o={type:"set",key:e,value:t,path:this.path,detail:r?.detail,origins:this.origins,timestamp:Date.now()};return{key:e,value:t,rest:i,event:o}}_resolveDelete(e,t){e=typeof e=="object"&&e?e.key:e;let r={type:"delete",key:e,path:this.path,detail:t?.detail,origins:this.origins,timestamp:Date.now()};return{key:e,event:r}}_resolveClear(e){return{event:{type:"clear",path:this.path,detail:e?.detail,origins:this.origins,timestamp:Date.now()}}}_resolveInputJson(e,t){if(typeof e!="object")throw new Error("Argument must be a valid JSON object");let r=this.hasTTL&&this.fieldLevelExpiry?Date.now()+this.ttl:null,s={},i={};for(let[n,a]of Object.entries(e)){if(t.hashed&&!(a&&typeof a=="object"))throw new Error(`A hash expected for field ${n}`);s[n]=t.hashed?a.value:a,i[n]=t.hashed?a:{value:a},r&&!i[n].expires?i[n].expires=r:this.hasTTL&&this.fieldLevelExpiry&&i[n].expires&&(i[n].expires=this._normalizeExpires(i[n].expires))}let o={type:"json",data:s,hashed:t?.hashed,merge:t?.merge,detail:t?.detail,path:this.path,origins:this.origins,timestamp:Date.now()};return{data:i,event:o}}observe(e,t,r={}){typeof e=="function"&&(r=t||{},t=e,e=[]);let s=this.#s.concat(e);return this._observe(s,t,r)}cleanup(){this._path(this.#s,!1)?.dispose()}async close(){}};var m=class d extends b{static#s=new Map;#t;#r;#e;#i;constructor({dbName:e="webqit_keyval",channel:t=null,...r}){super(r),this.#r=e,this.#e=this.path.join(":"),t&&(this.#i=new BroadcastChannel(t))}#o(e){e.onversionchange=()=>{e.close(),d.#s.delete(this.#r),this.#t=null}}async#n(){let e=this.#r;if(d.#s.has(e)&&(this.#t=d.#s.get(e),this.#t.objectStoreNames.contains(this.#e)))return this.#t;let t=async s=>new Promise((i,o)=>{let n=indexedDB.open(this.#r,s);n.onupgradeneeded=()=>{let a=n.result;a.objectStoreNames.contains(this.#e)||a.createObjectStore(this.#e)},n.onsuccess=()=>i(n.result),n.onerror=()=>o(n.error)}),r=await new Promise((s,i)=>{let o=indexedDB.open(this.#r);o.onsuccess=()=>s(o.result),o.onerror=()=>i(o.error)});if(r.objectStoreNames.contains(this.#e))this.#t=r;else{let s=r.version+1;r.close(),this.#t=await t(s)}return d.#s.set(e,this.#t),this.#o(this.#t),this.#t}#a(e="readonly"){return this.#t.transaction(this.#e,e).objectStore(this.#e)}async close(){this.#i?.close(),this.#t?.close(),d.#s.delete(this.#r),this.#t=null,await super.close()}async count(){return(await this.keys()).length}async keys(){return(await this.#h()).map(([e])=>e)}async values(){return(await this.#h()).map(([,e])=>e)}async entries(){return await this.#h()}async#h(e=!1){return await this.#n(),new Promise((t,r)=>{let s=this.#t.transaction(this.#e,"readonly"),i=s.objectStore(this.#e),o=i.getAll(),n=i.getAllKeys(),a,h,c=[],u=[];o.onsuccess=()=>{a=o.result},n.onsuccess=()=>{h=n.result},s.oncomplete=()=>{if(h.forEach((l,f)=>{let p=a[f];this._expired(p)?u.push(l):c.push([l,e?p:p.value])}),u.length){let l=this.#t.transaction(this.#e,"readwrite"),f=l.objectStore(this.#e);u.forEach(p=>f.delete(p)),l.oncomplete=()=>t(c),l.onerror=()=>r(l.error)}else t(c)},s.onerror=()=>r(s.error)})}async has(e){return e=typeof e=="object"&&e?e.key:e,(await this.keys()).includes(e)}async get(e){let t=typeof e=="object"&&e;return e=t?e.key:e,await this.#n(),new Promise((r,s)=>{let i=this.#a().get(e);i.onsuccess=async()=>{let o=i.result;if(!o||this._expired(o))if(o){let n=this.#t.transaction(this.#e,"readwrite");n.objectStore(this.#e).delete(e),n.oncomplete=()=>r(),n.onerror=()=>s(n.error)}else r();else r(t?o:o.value)},i.onerror=()=>s(i.error)})}async set(e,t,r={}){let s,i;return{key:e,value:t,rest:s,event:i}=this._resolveSet(e,t,r),await this.#n(),new Promise((o,n)=>{let a=this.#t.transaction(this.#e,"readwrite");a.objectStore(this.#e).put({value:t,...s},e),a.oncomplete=async()=>{await this._fire(i),this.#i?.postMessage(i),o()},a.onerror=()=>n(a.error)})}async delete(e,t={}){let r;return{key:e,event:r}=this._resolveDelete(e,t),await this.#n(),new Promise((s,i)=>{let o=this.#t.transaction(this.#e,"readwrite");o.objectStore(this.#e).delete(e),o.oncomplete=async()=>{await this._fire(r),this.#i?.postMessage(r),s()},o.onerror=()=>i(o.error)})}async clear(e={}){let{event:t}=this._resolveClear(e);return await this.#n(),new Promise((r,s)=>{let i=this.#t.transaction(this.#e,"readwrite");i.objectStore(this.#e).clear(),i.oncomplete=async()=>{await this._fire(t),this.#i?.postMessage(t),r()},i.onerror=()=>s(i.error)})}async json(e=null,t={}){if(e&&e!==!0){let{data:r,event:s}=this._resolveInputJson(e,t);return await this.#n(),new Promise((i,o)=>{let n=this.#t.transaction(this.#e,"readwrite"),a=n.objectStore(this.#e);t.merge||a.clear();for(let[h,c]of Object.entries(r))a.put(c,h);n.oncomplete=async()=>{await this._fire(s),this.#i?.postMessage(s),i()},n.onerror=()=>o(n.error)})}return Object.fromEntries(await this.#h(e))}};})();
//# sourceMappingURL=indexeddb.js.map
