(()=>{var p=class{static create(t){return new this(t)}#t;#s;#e;#i;#o;#r;#a;#n;get path(){return this.#t}get ttl(){return this.#s}get hasTTL(){return this.#s!==null}get registry(){return this.#e}get origins(){return this.#i}get options(){return this.#o}get fieldLevelExpiry(){return!0}constructor({path:t,ttl:e=null,registry:i=new Map,origins:s=[],fireHook:r=null,serializeHook:n=null,deserializeHook:o=null,...a}={}){if(!Array.isArray(t))throw new Error("Path must be an array if provided");if(this.#t=t,e!==null&&typeof e!="number")throw new Error("TTL must be a number (in milliseconds) if provided; null otherwise");if(this.#s=e,!(i instanceof Map))throw new Error("Registry must be an instance of Map if provided");if(this.#e=i,!Array.isArray(s))throw new Error("Origins must be an array if provided");if(this.#i=s,this.#o=a,r&&typeof r!="function")throw new Error("fireHook must be a function if provided");if(this.#r=r,n&&typeof n!="function")throw new Error("serializeHook must be a function if provided");if(this.#a=n||((h,...c)=>h===void 0?null:JSON.stringify(h,...c)),o&&typeof o!="function")throw new Error("deserializeHook must be a function if provided");this.#n=o||(h=>h===null?void 0:JSON.parse(h))}_serialize(t,...e){return this.#a(t,...e)}_deserialize(t){return this.#n(t)}_path(t,e=!0){if(!Array.isArray(t))throw new Error("Path length cannot be 0");return t.reduce((i,s,r)=>{if(e&&!i?.subtree.has(s)){let n=new Map,o=new Set,a=()=>{i.subtree.delete(s),!i.subtree.size&&i.entries?.size};i.subtree.set(s,{subtree:n,entries:o,context:i,dispose:a})}return e===0&&!i?.subtree.has(s)?i:i?.subtree.get(s)},{subtree:this.#e,entries:new Set})}_observe(t,e,i={}){let s=this._path(t,!0),r=()=>{s.entries.delete(n),s.entries.size||s.dispose()},n={callback:e,options:i,origins:this.#i,dispose:r};return s.entries.add(n),i.signal&&i.signal.addEventListener("abort",r),r}async _fire({path:t=this.#t,origins:e=this.#i,timestamp:i=Date.now(),...s}){if(!["set","delete","clear","json"].includes(s.type))throw new Error("Invalid event");let r=this._path(s.key?t.concat(s.key):t,0);if(!r)return;let n=[],o=r;do n.push(...o.entries);while((o=o.context)&&o.entries);let a=[],h=(c,f=s)=>{let{callback:d,options:u,origins:w,dispose:g}=c,l=e.length-1;for(;l>=(u.scope||0);l--)if(w[l]!==e[l])return;a.push(d({...f,path:t,scope:l+1,origins:e,timestamp:i})),u.once&&g()};if(n.forEach(c=>h(c)),s.type==="clear"||s.type==="json"){let c=this._path(t,!1);for(let[f,d]of c?.subtree.entries()||[]){let u={type:"delete",key:f};if(s.type==="json"&&s.data&&typeof s.data=="object"){if(f in s.data)u={type:"set",key:f,value:s.data[f]};else if(s.options?.merge)continue}for(let w of d.entries)h(w,u)}}this.#r&&a.push(this.#r({path:t,origins:e,timestamp:i,...s})),await Promise.all(a)}_normalizeExpires(t){if(t??!1){if(t instanceof Date)return t.getTime();if(typeof t=="number")return t<1e12?t*1e3:t;if(typeof t=="string"){let e=Date.parse(t);if(!Number.isNaN(e))return e}throw new TypeError(`Invalid expires value: ${t}`)}}_expired(t){return!this.hasTTL||!this.fieldLevelExpiry?!1:!!(t?.expires&&t.expires<=Date.now())}_resolveSet(t,e){let i=typeof t=="object"&&t,s;({key:t,value:e,...s}=i?t:{key:t,value:e}),this.hasTTL&&this.fieldLevelExpiry&&(s.expires?s.expires=this._normalizeExpires(s.expires):s.expires=Date.now()+this.ttl);let r={type:"set",key:t,value:e,path:this.path,origins:this.origins,timestamp:Date.now()};return{key:t,value:e,rest:s,event:r}}_resolveInputJson(t,e){if(typeof t!="object")throw new Error("Argument must be a valid JSON object");let i=this.hasTTL&&this.fieldLevelExpiry?Date.now()+this.ttl:null,s={},r={};for(let[o,a]of Object.entries(t)){if(e.hashed&&!(a&&typeof a=="object"))throw new Error(`A hash expected for field ${o}`);s[o]=e.hashed?a.value:a,r[o]=e.hashed?a:{value:a},i&&!r[o].expires?r[o].expires=i:this.hasTTL&&this.fieldLevelExpiry&&r[o].expires&&(r[o].expires=this._normalizeExpires(r[o].expires))}let n={type:"json",data:s,options:e,path:this.path,origins:this.origins,timestamp:Date.now()};return{data:r,event:n}}observe(t,e,i={}){typeof t=="function"&&(i=e||{},e=t,t=[]);let s=this.#t.concat(t);return this._observe(s,e,i)}cleanup(){this._path(this.#t,!1)?.dispose()}async close(){}};var y=class extends p{#t;#s;#e;constructor({storage:t="local",channel:e=null,...i}={}){super(i),this.#t=typeof t=="string"?t==="session"?window.sessionStorage:window.localStorage:t,this.#s=this.path.join(":"),e&&(this.#e=new BroadcastChannel(e))}#i(t){return`${this.#s}:${t}`}#o(t){return t?.startsWith(this.#s+":")}#r(t){let e=this.#i(t),i=this.#t.getItem(e);if(i==null)return;let s;try{s=this._deserialize(i)}catch{this.#t.removeItem(e);return}if(this._expired(s)){this.#t.removeItem(e);return}return s}#a(t,e){let i=this.#i(t);this.#t.setItem(i,this._serialize(e))}async close(){this.#e?.close(),await super.close()}async count(){return(await this.keys()).length}async keys(){return(await this.#n()).map(([t])=>t)}async values(){return(await this.#n()).map(([,t])=>t)}async entries(){return await this.#n()}async#n(t=!1){let e=[];for(let i=0;i<this.#t.length;i++){let s=this.#t.key(i);if(!this.#o(s))continue;let r=s.slice(this.#s.length+1),n=this.#r(r);n&&e.push([r,t?n:n.value])}return e}async has(t){return t=typeof t=="object"&&t?t.key:t,!!this.#r(t)}async get(t){let e=typeof t=="object"&&t;t=e?t.key:t;let i=this.#r(t);if(i)return e?i:i.value}async set(t,e){let i,s;({key:t,value:e,rest:i,event:s}=this._resolveSet(t,e)),this.#a(t,{value:e,...i}),this.#e?.postMessage(s),await this._fire(s)}async delete(t){t=typeof t=="object"&&t?t.key:t,this.#t.removeItem(this.#i(t));let e={type:"delete",key:t,path:this.path,origins:this.origins,timestamp:Date.now()};this.#e?.postMessage(e),await this._fire(e)}async clear(){for(let e=this.#t.length-1;e>=0;e--){let i=this.#t.key(e);this.#o(i)&&this.#t.removeItem(i)}let t={type:"clear",path:this.path,origins:this.origins,timestamp:Date.now()};this.#e?.postMessage(t),await this._fire(t)}async json(t=null,e={}){if(t&&t!==!0){let{data:i,event:s}=this._resolveInputJson(t,e);if(!e.merge)for(let r=this.#t.length-1;r>=0;r--){let n=this.#t.key(r);this.#o(n)&&this.#t.removeItem(n)}for(let[r,n]of Object.entries(i)){let o={...n};this.#a(r,o)}this.#e?.postMessage(s),await this._fire(s);return}return Object.fromEntries(await this.#n(t))}};})();
//# sourceMappingURL=webstorage.js.map
