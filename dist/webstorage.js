(()=>{var p=class{static create(e){return new this(e)}#e;#s;#t;#i;#o;#r;#a;#n;get path(){return this.#e}get ttl(){return this.#s}get hasTTL(){return this.#s!==null}get registry(){return this.#t}get origins(){return this.#i}get options(){return this.#o}get fieldLevelExpiry(){return!0}constructor({path:e,ttl:t=null,registry:s=new Map,origins:i=[],fireHook:r=null,serializeHook:n=null,deserializeHook:o=null,...a}={}){if(!Array.isArray(e))throw new Error("Path must be an array if provided");if(this.#e=e,t!==null&&typeof t!="number")throw new Error("TTL must be a number (in milliseconds) if provided; null otherwise");if(this.#s=t,!(s instanceof Map))throw new Error("Registry must be an instance of Map if provided");if(this.#t=s,!Array.isArray(i))throw new Error("Origins must be an array if provided");if(this.#i=i,this.#o=a,r&&typeof r!="function")throw new Error("fireHook must be a function if provided");if(this.#r=r,n&&typeof n!="function")throw new Error("serializeHook must be a function if provided");if(this.#a=n||((h,...l)=>h===void 0?null:JSON.stringify(h,...l)),o&&typeof o!="function")throw new Error("deserializeHook must be a function if provided");this.#n=o||(h=>h===null?void 0:JSON.parse(h))}_serialize(e,...t){return this.#a(e,...t)}_deserialize(e){return this.#n(e)}_path(e,t=!0){if(!Array.isArray(e))throw new Error("Path length cannot be 0");return e.reduce((s,i,r)=>{if(t&&!s?.subtree.has(i)){let n=new Map,o=new Set,a=()=>{s.subtree.delete(i),!s.subtree.size&&s.entries?.size};s.subtree.set(i,{subtree:n,entries:o,context:s,dispose:a})}return t===0&&!s?.subtree.has(i)?s:s?.subtree.get(i)},{subtree:this.#t,entries:new Set})}_observe(e,t,s={}){let i=this._path(e,!0),r=()=>{i.entries.delete(n),i.entries.size||i.dispose()},n={callback:t,options:s,origins:this.#i,dispose:r};return i.entries.add(n),s.signal&&s.signal.addEventListener("abort",r),r}async _fire({path:e=this.#e,origins:t=this.#i,timestamp:s=Date.now(),...i}){if(!["set","delete","clear","json"].includes(i.type))throw new Error("Invalid event");let r=this._path(i.key?e.concat(i.key):e,0);if(!r)return;let n=[],o=r;do n.push(...o.entries);while((o=o.context)&&o.entries);let a=[],h=(l,c=i)=>{let{callback:d,options:u,origins:w,dispose:g}=l,f=t.length-1;for(;f>=(u.scope||0);f--)if(w[f]!==t[f])return;a.push(d({...c,path:e,scope:f+1,origins:t,timestamp:s})),u.once&&g()};if(n.forEach(l=>h(l)),i.type==="clear"||i.type==="json"){let l=this._path(e,!1);for(let[c,d]of l?.subtree.entries()||[]){let u={type:"delete",key:c,detail:i.detail};if(i.type==="json"&&i.data&&typeof i.data=="object"){if(c in i.data)u={type:"set",key:c,value:i.data[c],detail:i.detail};else if(i.merge)continue}for(let w of d.entries)h(w,u)}}this.#r&&a.push(this.#r({path:e,origins:t,timestamp:s,...i})),await Promise.all(a)}_normalizeExpires(e){if(e??!1){if(e instanceof Date)return e.getTime();if(typeof e=="number")return e<1e12?e*1e3:e;if(typeof e=="string"){let t=Date.parse(e);if(!Number.isNaN(t))return t}throw new TypeError(`Invalid expires value: ${e}`)}}_expired(e){return!this.hasTTL||!this.fieldLevelExpiry?!1:!!(e?.expires&&e.expires<=Date.now())}_resolveSet(e,t,s){let i=typeof e=="object"&&e,r;({key:e,value:t,...r}=i?e:{key:e,value:t}),this.hasTTL&&this.fieldLevelExpiry&&(r.expires?r.expires=this._normalizeExpires(r.expires):r.expires=Date.now()+this.ttl);let n={type:"set",key:e,value:t,path:this.path,detail:s?.detail,origins:this.origins,timestamp:Date.now()};return{key:e,value:t,rest:r,event:n}}_resolveDelete(e,t){e=typeof e=="object"&&e?e.key:e;let s={type:"delete",key:e,path:this.path,detail:t?.detail,origins:this.origins,timestamp:Date.now()};return{key:e,event:s}}_resolveClear(e){return{event:{type:"clear",path:this.path,detail:e?.detail,origins:this.origins,timestamp:Date.now()}}}_resolveInputJson(e,t){if(typeof e!="object")throw new Error("Argument must be a valid JSON object");let s=this.hasTTL&&this.fieldLevelExpiry?Date.now()+this.ttl:null,i={},r={};for(let[o,a]of Object.entries(e)){if(t.hashed&&!(a&&typeof a=="object"))throw new Error(`A hash expected for field ${o}`);i[o]=t.hashed?a.value:a,r[o]=t.hashed?a:{value:a},s&&!r[o].expires?r[o].expires=s:this.hasTTL&&this.fieldLevelExpiry&&r[o].expires&&(r[o].expires=this._normalizeExpires(r[o].expires))}let n={type:"json",data:i,hashed:t?.hashed,merge:t?.merge,detail:t?.detail,path:this.path,origins:this.origins,timestamp:Date.now()};return{data:r,event:n}}observe(e,t,s={}){typeof e=="function"&&(s=t||{},t=e,e=[]);let i=this.#e.concat(e);return this._observe(i,t,s)}cleanup(){this._path(this.#e,!1)?.dispose()}async close(){}};var m=class extends p{#e;#s;#t;constructor({storage:e="local",channel:t=null,...s}={}){super(s),this.#e=typeof e=="string"?e==="session"?window.sessionStorage:window.localStorage:e,this.#s=this.path.join(":"),t&&(this.#t=new BroadcastChannel(t))}#i(e){return`${this.#s}:${e}`}#o(e){return e?.startsWith(this.#s+":")}#r(e){let t=this.#i(e),s=this.#e.getItem(t);if(s==null)return;let i;try{i=this._deserialize(s)}catch{this.#e.removeItem(t);return}if(this._expired(i)){this.#e.removeItem(t);return}return i}#a(e,t){let s=this.#i(e);this.#e.setItem(s,this._serialize(t))}async close(){this.#t?.close(),await super.close()}async count(){return(await this.keys()).length}async keys(){return(await this.#n()).map(([e])=>e)}async values(){return(await this.#n()).map(([,e])=>e)}async entries(){return await this.#n()}async#n(e=!1){let t=[];for(let s=0;s<this.#e.length;s++){let i=this.#e.key(s);if(!this.#o(i))continue;let r=i.slice(this.#s.length+1),n=this.#r(r);n&&t.push([r,e?n:n.value])}return t}async has(e){return e=typeof e=="object"&&e?e.key:e,!!this.#r(e)}async get(e){let t=typeof e=="object"&&e;e=t?e.key:e;let s=this.#r(e);if(s)return t?s:s.value}async set(e,t,s={}){let i,r;({key:e,value:t,rest:i,event:r}=this._resolveSet(e,t,s)),this.#a(e,{value:t,...i}),this.#t?.postMessage(r),await this._fire(r)}async delete(e,t={}){let s;({key:e,event:s}=this._resolveDelete(e,t)),this.#e.removeItem(this.#i(e)),this.#t?.postMessage(s),await this._fire(s)}async clear(e={}){let{event:t}=this._resolveClear(e);for(let s=this.#e.length-1;s>=0;s--){let i=this.#e.key(s);this.#o(i)&&this.#e.removeItem(i)}this.#t?.postMessage(t),await this._fire(t)}async json(e=null,t={}){if(e&&e!==!0){let{data:s,event:i}=this._resolveInputJson(e,t);if(!t.merge)for(let r=this.#e.length-1;r>=0;r--){let n=this.#e.key(r);this.#o(n)&&this.#e.removeItem(n)}for(let[r,n]of Object.entries(s)){let o={...n};this.#a(r,o)}this.#t?.postMessage(i),await this._fire(i);return}return Object.fromEntries(await this.#n(e))}};})();
//# sourceMappingURL=webstorage.js.map
