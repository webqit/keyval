(()=>{var p=class{static create(t){return new this(t)}#t;#i;#s;#e;#r;#n;#o;#a;get path(){return this.#t}get ttl(){return this.#i}get hasTTL(){return this.#i!==null}get registry(){return this.#s}get origins(){return this.#e}get options(){return this.#r}get fieldLevelExpiry(){return!0}constructor({path:t,ttl:s=null,registry:i=new Map,origins:e=[],fireHook:r=null,serializeHook:a=null,deserializeHook:n=null,...o}={}){if(!Array.isArray(t))throw new Error("Path must be an array if provided");if(this.#t=t,s!==null&&typeof s!="number")throw new Error("TTL must be a number (in milliseconds) if provided; null otherwise");if(this.#i=s,!(i instanceof Map))throw new Error("Registry must be an instance of Map if provided");if(this.#s=i,!Array.isArray(e))throw new Error("Origins must be an array if provided");if(this.#e=e,this.#r=o,r&&typeof r!="function")throw new Error("fireHook must be a function if provided");if(this.#n=r,a&&typeof a!="function")throw new Error("serializeHook must be a function if provided");if(this.#o=a||((h,...f)=>h===void 0?null:JSON.stringify(h,...f)),n&&typeof n!="function")throw new Error("deserializeHook must be a function if provided");this.#a=n||(h=>h===null?void 0:JSON.parse(h))}_serialize(t,...s){return this.#o(t,...s)}_deserialize(t){return this.#a(t)}_path(t,s=!0){if(!Array.isArray(t))throw new Error("Path length cannot be 0");return t.reduce((i,e,r)=>{if(s&&!i?.subtree.has(e)){let a=new Map,n=new Set,o=()=>{i.subtree.delete(e),!i.subtree.size&&i.entries?.size};i.subtree.set(e,{subtree:a,entries:n,context:i,dispose:o})}return s===0&&!i?.subtree.has(e)?i:i?.subtree.get(e)},{subtree:this.#s,entries:new Set})}_observe(t,s,i={}){let e=this._path(t,!0),r=()=>{e.entries.delete(a),e.entries.size||e.dispose()},a={callback:s,options:i,origins:this.#e,dispose:r};return e.entries.add(a),i.signal&&i.signal.addEventListener("abort",r),r}async _fire({path:t=this.#t,origins:s=this.#e,timestamp:i=Date.now(),...e}){if(!["set","delete","clear","json"].includes(e.type))throw new Error("Invalid event");let r=this._path(e.key?t.concat(e.key):t,0);if(!r)return;let a=[],n=r;do a.push(...n.entries);while((n=n.context)&&n.entries);let o=[],h=(f,l=e)=>{let{callback:d,options:u,origins:w,dispose:y}=f,c=s.length-1;for(;c>=(u.scope||0);c--)if(w[c]!==s[c])return;o.push(d({...l,path:t,scope:c+1,origins:s,timestamp:i})),u.once&&y()};if(a.forEach(f=>h(f)),e.type==="clear"||e.type==="json"){let f=this._path(t,!1);for(let[l,d]of f?.subtree.entries()||[]){let u={type:"delete",key:l};if(e.type==="json"&&e.data&&typeof e.data=="object"){if(l in e.data)u={type:"set",key:l,value:e.data[l]};else if(e.options?.merge)continue}for(let w of d.entries)h(w,u)}}this.#n&&o.push(this.#n({path:t,origins:s,timestamp:i,...e})),await Promise.all(o)}_normalizeExpires(t){if(t??!1){if(t instanceof Date)return t.getTime();if(typeof t=="number")return t<1e12?t*1e3:t;if(typeof t=="string"){let s=Date.parse(t);if(!Number.isNaN(s))return s}throw new TypeError(`Invalid expires value: ${t}`)}}_expired(t){return!this.hasTTL||!this.fieldLevelExpiry?!1:!!(t?.expires&&t.expires<=Date.now())}_resolveSet(t,s){let i=typeof t=="object"&&t,e;({key:t,value:s,...e}=i?t:{key:t,value:s}),this.hasTTL&&this.fieldLevelExpiry&&(e.expires?e.expires=this._normalizeExpires(e.expires):e.expires=Date.now()+this.ttl);let r={type:"set",key:t,value:s,path:this.path,origins:this.origins,timestamp:Date.now()};return{key:t,value:s,rest:e,event:r}}_resolveInputJson(t,s){if(typeof t!="object")throw new Error("Argument must be a valid JSON object");let i=this.hasTTL&&this.fieldLevelExpiry?Date.now()+this.ttl:null,e={},r={};for(let[n,o]of Object.entries(t)){if(s.hashed&&!(o&&typeof o=="object"))throw new Error(`A hash expected for field ${n}`);e[n]=s.hashed?o.value:o,r[n]=s.hashed?o:{value:o},i&&!r[n].expires?r[n].expires=i:this.hasTTL&&this.fieldLevelExpiry&&r[n].expires&&(r[n].expires=this._normalizeExpires(r[n].expires))}let a={type:"json",data:e,options:s,path:this.path,origins:this.origins,timestamp:Date.now()};return{data:r,event:a}}observe(t,s,i={}){typeof t=="function"&&(i=s||{},s=t,t=[]);let e=this.#t.concat(t);return this._observe(e,s,i)}cleanup(){this._path(this.#t,!1)?.dispose()}async close(){}};var m=class extends p{#t;#i;#s;#e;constructor({storage:t=null,channel:s=null,cookiePath:i="/",...e}={}){if(super(e),!t&&typeof cookieStore>"u")throw new Error("cookieStore is not available in this environment");this.#t=t||cookieStore,this.#i=this.path.join(":"),this.#e=i,s&&(this.#s=new BroadcastChannel(s))}#r(t){return`${this.#i}:${t}`}#n(t){return t?.startsWith(this.#i+":")}async#o(t,s=!0){if(typeof t=="string"&&(t=await this.#t.get(t)),!!t){if(this._expired(t)){await this.#t.delete(t.name,{path:this.#e}).catch(()=>{});return}return s&&(t.value=this._deserialize(t.value)),t}}async close(){this.#s?.close(),await super.close()}async count(){return(await this.keys()).length}async keys(){return(await this.#a()).map(([t])=>t)}async values(){return(await this.#a()).map(([,t])=>t)}async entries(){return await this.#a()}async#a(t=!1){let s=await this.#t.getAll(),i=[];for(let e of s){if(!this.#n(e.name)||!(e=await this.#o(e)))continue;let r=e.name.slice(this.#i.length+1);delete e.name,i.push([r,t?e:e.value])}return i}async has(t){return t=typeof t=="object"&&t?t.key:t,!!await this.#o(this.#r(t),!1)}async get(t){let s=typeof t=="object"&&t;t=s?t.key:t;let i=await this.#o(this.#r(t));if(i)return delete i.name,s?i:i.value}async set(t,s){let i,e;({key:t,value:s,rest:i,event:e}=this._resolveSet(t,s)),await this.#t.set({path:this.#e,...i,name:this.#r(t),value:this._serialize(s)}),this.#s?.postMessage(e),await this._fire(e)}async delete(t){t=typeof t=="object"&&t?t.key:t,await this.#t.delete(this.#r(t),{path:this.#e});let s={type:"delete",key:t,path:this.path,origins:this.origins,timestamp:Date.now()};this.#s?.postMessage(s),await this._fire(s)}async clear(){let t=await this.#t.getAll();for(let i of t)this.#n(i.name)&&await this.#t.delete(i.name,{path:this.#e}).catch(()=>{});let s={type:"clear",path:this.path,origins:this.origins,timestamp:Date.now()};this.#s?.postMessage(s),await this._fire(s)}async json(t=null,s={}){if(t&&t!==!0){let{data:i,event:e}=this._resolveInputJson(t,s);if(!s.merge){let r=await this.#t.getAll();for(let a of r)this.#n(a.name)&&await this.#t.delete(a.name,{path:this.#e}).catch(()=>{})}for(let[r,{value:a,...n}]of Object.entries(i))await this.#t.set({path:this.#e,...n,name:this.#r(r),value:this._serialize(a)});this.#s?.postMessage(e),await this._fire(e);return}return Object.fromEntries(await this.#a(t))}};})();
//# sourceMappingURL=cookiestore.js.map
