(()=>{var b=class{static create(t){return new this(t)}#s;#e;#r;#t;#i;#o;#n;#a;get path(){return this.#s}get ttl(){return this.#e}get registry(){return this.#r}get origins(){return this.#t}get options(){return this.#i}get fieldLevelExpiry(){return!0}constructor({path:t,ttl:s=0,registry:r=new Map,origins:e=[],fireHook:n=null,serializeHook:o=null,deserializeHook:i=null,...a}={}){this.#s=t,this.#e=s,this.#r=r,this.#t=e,this.#i=a,this.#o=n,this.#n=o||((c,...h)=>c===void 0?null:JSON.stringify(c,...h)),this.#a=i||(c=>c===null?void 0:JSON.parse(c))}_serialize(t,...s){return this.#n(t,...s)}_deserialize(t){return this.#a(t)}_path(t,s=!0){if(!Array.isArray(t))throw new Error("Path length cannot be 0");return t.reduce((r,e,n)=>{if(s&&!r?.subtree.has(e)){let o=new Map,i=new Set,a=()=>{r.subtree.delete(e),!r.subtree.size&&r.entries?.size};r.subtree.set(e,{subtree:o,entries:i,context:r,dispose:a})}return s===0&&!r?.subtree.has(e)?r:r?.subtree.get(e)},{subtree:this.#r,entries:new Set})}_observe(t,s,r={}){let e=this._path(t,!0),n=()=>{e.entries.delete(o),e.entries.size||e.dispose()},o={callback:s,options:r,origins:this.#t,dispose:n};return e.entries.add(o),r.signal&&r.signal.addEventListener("abort",n),n}async _fire({path:t=this.#s,origins:s=this.#t,timestamp:r=Date.now(),...e}){if(!["set","delete","clear","json"].includes(e.type))throw new Error("Invalid event");let n=this._path(e.key?t.concat(e.key):t,0);if(!n)return;let o=[],i=n;do o.push(...i.entries);while((i=i.context)&&i.entries);let a=[],c=(h,u=e)=>{let{callback:l,options:p,origins:f,dispose:g}=h,w=s.length-1;for(;w>=(p.scope||0);w--)if(f[w]!==s[w])return;a.push(l({...u,path:t,scope:w+1,origins:s,timestamp:r})),p.once&&g()};if(o.forEach(h=>c(h)),e.type==="clear"||e.type==="json"){let h=this._path(t,!1);for(let[u,l]of h?.subtree.entries()||[]){let p={type:"delete",key:u};if(e.type==="json"&&e.data&&typeof e.data=="object"){if(u in e.data)p={type:"set",key:u,value:e.data[u]};else if(e.options?.merge)continue}for(let f of l.entries)c(f,p)}}this.#o&&a.push(this.#o({path:t,origins:s,timestamp:r,...e})),await Promise.all(a)}_normalizeExpires(t){if(t??!1){if(t instanceof Date)return t.getTime();if(typeof t=="number")return t<1e12?t*1e3:t;if(typeof t=="string"){let s=Date.parse(t);if(!Number.isNaN(s))return s}throw new TypeError(`Invalid expires value: ${t}`)}}_expired(t){return!this.ttl||!this.fieldLevelExpiry?!1:!!(t?.expires&&t.expires<=Date.now())}_resolveSet(t,s){let r=typeof t=="object"&&t,e;({key:t,value:s,...e}=r?t:{key:t,value:s}),this.ttl&&this.fieldLevelExpiry&&(e.expires?e.expires=this._normalizeExpires(e.expires):e.expires=Date.now()+this.ttl);let n={type:"set",key:t,value:s,path:this.path,origins:this.origins,timestamp:Date.now()};return{key:t,value:s,rest:e,event:n}}_resolveInputJson(t,s){if(typeof t!="object")throw new Error("Argument must be a valid JSON object");let r=this.ttl&&this.fieldLevelExpiry?Date.now()+this.ttl:null,e={},n={};for(let[i,a]of Object.entries(t)){if(s.hashed&&!(a&&typeof a=="object"))throw new Error(`A hash expected for field ${i}`);e[i]=s.hashed?a.value:a,n[i]=s.hashed?a:{value:a},r&&!n[i].expires?n[i].expires=r:this.ttl&&this.fieldLevelExpiry&&n[i].expires&&(n[i].expires=this._normalizeExpires(n[i].expires))}let o={type:"json",data:e,options:s,path:this.path,origins:this.origins,timestamp:Date.now()};return{data:n,event:o}}observe(t,s,r={}){typeof t=="function"&&(r=s||{},s=t,t=[]);let e=this.#s.concat(t);return this._observe(e,s,r)}cleanup(){this._path(this.#s,!1)?.dispose()}async close(){}};var m=class d extends b{static#s=new Map;#e;#r;#t;#i;constructor({dbName:t="webqit_keyval",channel:s=null,...r}){super(r),this.#r=t,this.#t=this.path.join(":"),s&&(this.#i=new BroadcastChannel(s))}#o(t){t.onversionchange=()=>{t.close(),d.#s.delete(this.#r),this.#e=null}}async#n(){let t=this.#r;if(d.#s.has(t)&&(this.#e=d.#s.get(t),this.#e.objectStoreNames.contains(this.#t)))return this.#e;let s=async e=>new Promise((n,o)=>{let i=indexedDB.open(this.#r,e);i.onupgradeneeded=()=>{let a=i.result;a.objectStoreNames.contains(this.#t)||a.createObjectStore(this.#t)},i.onsuccess=()=>n(i.result),i.onerror=()=>o(i.error)}),r=await new Promise((e,n)=>{let o=indexedDB.open(this.#r);o.onsuccess=()=>e(o.result),o.onerror=()=>n(o.error)});if(r.objectStoreNames.contains(this.#t))this.#e=r;else{let e=r.version+1;r.close(),this.#e=await s(e)}return d.#s.set(t,this.#e),this.#o(this.#e),this.#e}#a(t="readonly"){return this.#e.transaction(this.#t,t).objectStore(this.#t)}async close(){this.#i?.close(),this.#e?.close(),d.#s.delete(this.#r),this.#e=null,await super.close()}async count(){return(await this.keys()).length}async keys(){return(await this.#c()).map(([t])=>t)}async values(){return(await this.#c()).map(([,t])=>t)}async entries(){return await this.#c()}async#c(t=!1){return await this.#n(),new Promise((s,r)=>{let e=this.#e.transaction(this.#t,"readonly"),n=e.objectStore(this.#t),o=n.getAll(),i=n.getAllKeys(),a,c,h=[],u=[];o.onsuccess=()=>{a=o.result},i.onsuccess=()=>{c=i.result},e.oncomplete=()=>{if(c.forEach((l,p)=>{let f=a[p];this._expired(f)?u.push(l):h.push([l,t?f:f.value])}),u.length){let l=this.#e.transaction(this.#t,"readwrite"),p=l.objectStore(this.#t);u.forEach(f=>p.delete(f)),l.oncomplete=()=>s(h),l.onerror=()=>r(l.error)}else s(h)},e.onerror=()=>r(e.error)})}async has(t){return t=typeof t=="object"&&t?t.key:t,(await this.keys()).includes(t)}async get(t){let s=typeof t=="object"&&t;return t=s?t.key:t,await this.#n(),new Promise((r,e)=>{let n=this.#a().get(t);n.onsuccess=async()=>{let o=n.result;if(!o||this._expired(o))if(o){let i=this.#e.transaction(this.#t,"readwrite");i.objectStore(this.#t).delete(t),i.oncomplete=()=>r(),i.onerror=()=>e(i.error)}else r();else r(s?o:o.value)},n.onerror=()=>e(n.error)})}async set(t,s){let r,e;return{key:t,value:s,rest:r,event:e}=this._resolveSet(t,s),await this.#n(),new Promise((n,o)=>{let i=this.#e.transaction(this.#t,"readwrite");i.objectStore(this.#t).put({value:s,...r},t),i.oncomplete=async()=>{await this._fire(e),this.#i?.postMessage(e),n()},i.onerror=()=>o(i.error)})}async delete(t){t=typeof t=="object"&&t?t.key:t;let s={type:"delete",key:t,path:this.path,origins:this.origins,timestamp:Date.now()};return await this.#n(),new Promise((r,e)=>{let n=this.#e.transaction(this.#t,"readwrite");n.objectStore(this.#t).delete(t),n.oncomplete=async()=>{await this._fire(s),this.#i?.postMessage(s),r()},n.onerror=()=>e(n.error)})}async clear(){let t={type:"clear",path:this.path,origins:this.origins,timestamp:Date.now()};return await this.#n(),new Promise((s,r)=>{let e=this.#e.transaction(this.#t,"readwrite");e.objectStore(this.#t).clear(),e.oncomplete=async()=>{await this._fire(t),this.#i?.postMessage(t),s()},e.onerror=()=>r(e.error)})}async json(t=null,s={}){if(t&&t!==!0){let{data:r,event:e}=this._resolveInputJson(t,s);return await this.#n(),new Promise((n,o)=>{let i=this.#e.transaction(this.#t,"readwrite"),a=i.objectStore(this.#t);s.merge||a.clear();for(let[c,h]of Object.entries(r))a.put(h,c);i.oncomplete=async()=>{await this._fire(e),this.#i?.postMessage(e),n()},i.onerror=()=>o(i.error)})}return Object.fromEntries(await this.#c(t))}};})();
//# sourceMappingURL=idb.js.map
