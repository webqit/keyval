(()=>{var w=class{static create(t){return new this(t)}#s;#e;#r;#t;get path(){return this.#s}get ttl(){return this.#e}get registry(){return this.#r}get origins(){return this.#t}constructor({path:t,ttl:r=0,registry:s=new Map,origins:e=[]}={}){this.#s=t,this.#e=r,this.#r=s,this.#t=e}_path(t,r=!0){if(!Array.isArray(t)||!t.length)throw new Error("Path length cannot be 0");return t.reduce((s,e,i)=>{if(r&&!s?.subtree.has(e)){let n=new Map,o=new Set,a=()=>{s.subtree.delete(e),!s.subtree.size&&s.entries?.size};s.subtree.set(e,{subtree:n,entries:o,context:s,dispose:a})}return r===0&&i&&!s?.subtree.has(e)?s:s?.subtree.get(e)},{subtree:this.#r})}_observe(t,r,s={}){let e=this._path(t,!0),i=()=>{e.entries.delete(n),e.entries.size||e.dispose()},n={callback:r,options:s,origins:this.#t,dispose:i};return e.entries.add(n),s.signal&&s.signal.addEventListener("abort",i),i}async _fire({path:t=this.#s,origins:r=this.#t,timestamp:s=Date.now(),...e}){if(!["set","delete","clear","json"].includes(e.type))throw new Error("Invalid event");let i=this._path(e.key?t.concat(e.key):t,0);if(!i)return;let n=[],o=i;do n.push(...o.entries);while((o=o.context)&&o.entries);let a=[],l=(c,h=e)=>{let{callback:d,options:p,origins:y,dispose:b}=c,f=r.length-1;for(;f>=(p.scope||0);f--)if(y[f]!==r[f])return;a.push(d({...h,path:t,scope:f+1,origins:r,timestamp:s})),p.once&&b()};if(n.forEach(c=>l(c)),e.type==="clear"||e.type==="json"){let c=this._path(t,!1);for(let[h,d]of c?.subtree.entries()||[]){let p={type:"delete",key:h};if(e.type==="json"&&e.data&&typeof e.data=="object"){if(h in e.data)p={type:"set",key:h,value:e.data[h]};else if(e.options?.merge)continue}for(let y of d.entries)l(y,p)}}await Promise.all(a)}observe(t,r,s={}){typeof t=="function"&&(s=r||{},r=t,t=[]);let e=this.#s.concat(t);return this._observe(e,r,s)}cleanup(){this._path(this.#s,!1)?.dispose()}async close(){}};var m=class u extends w{static#s=new Map;#e;#r;#t;#n;constructor({dbName:t="webqit_keyval",channel:r=null,...s}){super(s),this.#r=t,this.#t=this.path.join(":"),r&&(this.#n=new BroadcastChannel(r))}#l(t){t.onversionchange=()=>{t.close(),u.#s.delete(this.#r),this.#e=null}}async#i(){let t=this.#r;if(u.#s.has(t)&&(this.#e=u.#s.get(t),this.#e.objectStoreNames.contains(this.#t)))return this.#e;let r=async e=>new Promise((i,n)=>{let o=indexedDB.open(this.#r,e);o.onupgradeneeded=()=>{let a=o.result;a.objectStoreNames.contains(this.#t)||a.createObjectStore(this.#t)},o.onsuccess=()=>i(o.result),o.onerror=()=>n(o.error)}),s=await new Promise((e,i)=>{let n=indexedDB.open(this.#r);n.onsuccess=()=>e(n.result),n.onerror=()=>i(n.error)});if(s.objectStoreNames.contains(this.#t))this.#e=s;else{let e=s.version+1;s.close(),this.#e=await r(e)}return u.#s.set(t,this.#e),this.#l(this.#e),this.#e}#o(t="readonly"){return this.#e.transaction(this.#t,t).objectStore(this.#t)}#a(t){return t?.expiresAt&&t.expiresAt<=Date.now()}#c(t){return{value:t,expiresAt:this.ttl?Date.now()+this.ttl*1e3:null}}async close(){this.#n?.close(),this.#e?.close(),u.#s.delete(this.#r),this.#e=null,await super.close()}async keys(){return await this.#i(),new Promise((t,r)=>{let s=this.#o().getAllKeys();s.onsuccess=()=>t(s.result),s.onerror=()=>r(s.error)})}async values(){return await this.#i(),new Promise((t,r)=>{let s=this.#o().getAll();s.onsuccess=()=>{t(s.result.filter(e=>!this.#a(e)).map(e=>e.value))},s.onerror=()=>r(s.error)})}async entries(){return await this.#h()}async#h(t=!1){return await this.#i(),new Promise((r,s)=>{let e=this.#e.transaction(this.#t,"readonly"),i=e.objectStore(this.#t),n=i.getAll(),o=i.getAllKeys(),a,l;n.onsuccess=()=>{a=n.result},o.onsuccess=()=>{l=o.result},e.oncomplete=()=>{r(l.map((c,h)=>[c,a[h]]).filter(([,c])=>!this.#a(c)).map(([c,h])=>[c,t?h:h.value]))},e.onerror=()=>s(e.error)})}async count(){return(await this.entries()).length}async has(t){return await this.get(t)!==void 0}async get(t){return await this.#i(),new Promise((r,s)=>{let e=this.#o().get(t);e.onsuccess=async()=>{let i=e.result;!i||this.#a(i)?(i&&await this.delete(t),r(void 0)):r(i.value)},e.onerror=()=>s(e.error)})}async set(t,r){let s={type:"set",key:t,value:r,path:this.path,origins:this.origins,timestamp:Date.now()};return await this.#i(),new Promise((e,i)=>{let n=this.#e.transaction(this.#t,"readwrite");n.objectStore(this.#t).put(this.#c(r),t),n.oncomplete=async()=>{await this._fire(s),this.#n?.postMessage(s),e()},n.onerror=()=>i(n.error)})}async delete(t){let r={type:"delete",key:t,path:this.path,origins:this.origins,timestamp:Date.now()};return await this.#i(),new Promise((s,e)=>{let i=this.#e.transaction(this.#t,"readwrite");i.objectStore(this.#t).delete(t),i.oncomplete=async()=>{await this._fire(r),this.#n?.postMessage(r),s()},i.onerror=()=>e(i.error)})}async clear(){let t={type:"clear",path:this.path,origins:this.origins,timestamp:Date.now()};return await this.#i(),new Promise((r,s)=>{let e=this.#e.transaction(this.#t,"readwrite");e.objectStore(this.#t).clear(),e.oncomplete=async()=>{await this._fire(t),this.#n?.postMessage(t),r()},e.onerror=()=>s(e.error)})}async json(t=null,r={}){if(t&&t!==!0){if(typeof t!="object")throw new Error("Argument must be a valid JSON object");let s={},e={};for(let[n,o]of Object.entries(t)){if(r.hashed&&!(o&&typeof o=="object"))throw new Error(`A hash expected for field ${n}`);s[n]=r.hashed?o.value:o,e[n]=r.hashed?{...o,...this.#c(o.value)}:this.#c(o)}let i={type:"json",data:s,options:r,path:this.path,origins:this.origins,timestamp:Date.now()};return await this.#i(),new Promise((n,o)=>{let a=this.#e.transaction(this.#t,"readwrite"),l=a.objectStore(this.#t);r.merge||l.clear();for(let[c,h]of Object.entries(e))l.put(h,c);a.oncomplete=async()=>{await this._fire(i),this.#n?.postMessage(i),n()},a.onerror=()=>o(a.error)})}return Object.fromEntries(await this.#h(t))}};})();
//# sourceMappingURL=idb.js.map
