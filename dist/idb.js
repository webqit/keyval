(()=>{var w=class{static create(t){return new this(t)}#s;#e;#r;#t;get path(){return this.#s}get ttl(){return this.#e}get registry(){return this.#r}get origins(){return this.#t}constructor({path:t,ttl:r=0,registry:e=new Map,origins:s=[]}={}){this.#s=t,this.#e=r,this.#r=e,this.#t=s}_path(t,r=!0){if(!Array.isArray(t)||!t.length||t.length>this.#s.length+1)throw new Error(`Path length must be between 1 and ${this.#s.length+1}`);return t.reduce((e,s,i)=>{if(r===0&&i&&!e.subtree.has(s))return e;if(r&&!e.subtree.has(s)){let n=new Map,o=new Set,a=()=>e.subtree.delete(s);e.subtree.set(s,{subtree:n,entries:o,context:e,dispose:a})}return e?.subtree.get(s)},{subtree:this.#r})}_observe(t,r,e={}){let s=this._path(t,!0),i=()=>{s.entries.delete(n),s.entries.size||s.dispose()},n={callback:r,options:e,origins:this.#t,dispose:i};return s.entries.add(n),e.signal&&e.signal.addEventListener("abort",i),i}async _fire({path:t=this.#s,origins:r=this.#t,timestamp:e=Date.now(),...s}){if(!["set","delete","clear"].includes(s.type))throw new Error("Invalid event");let i=this._path(t,0);if(!i)return;let n=[],o=i;do n.push(...o.entries);while((o=o.context)&&o.entries);let a=[],c=(h,d=t)=>{let{callback:f,options:p,origins:m,dispose:b}=h,u=this.#t.length-1;for(;u>=(p.scope||0);u--)if(m[u]!==this.#t[u])return;a.push(f({...s,path:d,scope:u+1,origins:r,timestamp:e})),p.once&&b()};if(n.forEach(c),s.type==="clear"){let h=this._path(t,!1);for(let[d,f]of h?.subtree.entries()||[])for(let p of f.entries)c(p,t.concat(d))}await Promise.all(a)}observe(t,r,e={}){typeof t=="function"&&(e=r||{},r=t,t=[]);let s=this.#s.concat(t);return this._observe(s,r,e)}cleanup(){this._path(this.#s,!1)?.dispose()}async close(){}};var g=class l extends w{static#s=new Map;#e;#r;#t;#n;constructor({dbName:t="webqit",channel:r=null,...e}){super(e),this.#r=t,this.#t=this.path.join(":"),r&&(this.#n=new BroadcastChannel(r))}#c(t){t.onversionchange=()=>{t.close(),l.#s.delete(this.#r),this.#e=null}}async#i(){let t=this.#r;if(l.#s.has(t)&&(this.#e=l.#s.get(t),this.#e.objectStoreNames.contains(this.#t)))return this.#e;let r=async s=>new Promise((i,n)=>{let o=indexedDB.open(this.#r,s);o.onupgradeneeded=()=>{let a=o.result;a.objectStoreNames.contains(this.#t)||a.createObjectStore(this.#t)},o.onsuccess=()=>i(o.result),o.onerror=()=>n(o.error)}),e=await new Promise((s,i)=>{let n=indexedDB.open(this.#r);n.onsuccess=()=>s(n.result),n.onerror=()=>i(n.error)});if(e.objectStoreNames.contains(this.#t))this.#e=e;else{let s=e.version+1;e.close(),this.#e=await r(s)}return l.#s.set(t,this.#e),this.#c(this.#e),this.#e}#o(t="readonly"){return this.#e.transaction(this.#t,t).objectStore(this.#t)}#a(t){return t?.expiresAt&&t.expiresAt<=Date.now()}#h(t){return{value:t,expiresAt:this.ttl?Date.now()+this.ttl*1e3:null}}async close(){this.#n?.close(),this.#e?.close(),l.#s.delete(this.#r),this.#e=null,await super.close()}async has(t){return await this.get(t)!==void 0}async get(t){return await this.#i(),new Promise((r,e)=>{let s=this.#o().get(t);s.onsuccess=async()=>{let i=s.result;!i||this.#a(i)?(i&&await this.delete(t),r(void 0)):r(i.value)},s.onerror=()=>e(s.error)})}async set(t,r){await this.#i();let e={type:"set",key:t,value:r,path:this.path,origins:this.origins,timestamp:Date.now()};return new Promise((s,i)=>{let n=this.#e.transaction(this.#t,"readwrite");n.objectStore(this.#t).put(this.#h(r),t),n.oncomplete=async()=>{await this._fire(e),this.#n?.postMessage(e),s()},n.onerror=()=>i(n.error)})}async delete(t){await this.#i();let r={type:"delete",key:t,path:this.path,origins:this.origins,timestamp:Date.now()};return new Promise((e,s)=>{let i=this.#e.transaction(this.#t,"readwrite");i.objectStore(this.#t).delete(t),i.oncomplete=async()=>{await this._fire(r),this.#n?.postMessage(r),e()},i.onerror=()=>s(i.error)})}async clear(){await this.#i();let t={type:"clear",path:this.path,origins:this.origins,timestamp:Date.now()};return new Promise((r,e)=>{let s=this.#e.transaction(this.#t,"readwrite");s.objectStore(this.#t).clear(),s.oncomplete=async()=>{await this._fire(t),this.#n?.postMessage(t),r()},s.onerror=()=>e(s.error)})}async keys(){return await this.#i(),new Promise((t,r)=>{let e=this.#o().getAllKeys();e.onsuccess=()=>t(e.result),e.onerror=()=>r(e.error)})}async values(){return await this.#i(),new Promise((t,r)=>{let e=this.#o().getAll();e.onsuccess=()=>{t(e.result.filter(s=>!this.#a(s)).map(s=>s.value))},e.onerror=()=>r(e.error)})}async entries(){return await this.#i(),new Promise((t,r)=>{let e=this.#e.transaction(this.#t,"readonly"),s=e.objectStore(this.#t),i=s.getAll(),n=s.getAllKeys(),o,a;i.onsuccess=()=>{o=i.result},n.onsuccess=()=>{a=n.result},e.oncomplete=()=>{t(a.map((c,h)=>[c,o[h]]).filter(([,c])=>!this.#a(c)).map(([c,h])=>[c,h.value]))},e.onerror=()=>r(e.error)})}async count(){return(await this.entries()).length}};})();
//# sourceMappingURL=idb.js.map
