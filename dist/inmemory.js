(()=>{var p=class{static create(t){return new this(t)}#t;#e;#s;#r;#n;#i;#a;#o;get path(){return this.#t}get ttl(){return this.#e}get hasTTL(){return this.#e!==null}get registry(){return this.#s}get origins(){return this.#r}get options(){return this.#n}get fieldLevelExpiry(){return!0}constructor({path:t,ttl:e=null,registry:r=new Map,origins:s=[],fireHook:i=null,serializeHook:a=null,deserializeHook:n=null,...o}={}){if(!Array.isArray(t))throw new Error("Path must be an array if provided");if(this.#t=t,e!==null&&typeof e!="number")throw new Error("TTL must be a number (in milliseconds) if provided; null otherwise");if(this.#e=e,!(r instanceof Map))throw new Error("Registry must be an instance of Map if provided");if(this.#s=r,!Array.isArray(s))throw new Error("Origins must be an array if provided");if(this.#r=s,this.#n=o,i&&typeof i!="function")throw new Error("fireHook must be a function if provided");if(this.#i=i,a&&typeof a!="function")throw new Error("serializeHook must be a function if provided");if(this.#a=a||((h,...c)=>h===void 0?null:JSON.stringify(h,...c)),n&&typeof n!="function")throw new Error("deserializeHook must be a function if provided");this.#o=n||(h=>h===null?void 0:JSON.parse(h))}_serialize(t,...e){return this.#a(t,...e)}_deserialize(t){return this.#o(t)}_path(t,e=!0){if(!Array.isArray(t))throw new Error("Path length cannot be 0");return t.reduce((r,s,i)=>{if(e&&!r?.subtree.has(s)){let a=new Map,n=new Set,o=()=>{r.subtree.delete(s),!r.subtree.size&&r.entries?.size};r.subtree.set(s,{subtree:a,entries:n,context:r,dispose:o})}return e===0&&!r?.subtree.has(s)?r:r?.subtree.get(s)},{subtree:this.#s,entries:new Set})}_observe(t,e,r={}){let s=this._path(t,!0),i=()=>{s.entries.delete(a),s.entries.size||s.dispose()},a={callback:e,options:r,origins:this.#r,dispose:i};return s.entries.add(a),r.signal&&r.signal.addEventListener("abort",i),i}async _fire({path:t=this.#t,origins:e=this.#r,timestamp:r=Date.now(),...s}){if(!["set","delete","clear","patch"].includes(s.type))throw new Error("Invalid event");let i=this._path(s.key?t.concat(s.key):t,0);if(!i)return;let a=[],n=i;do a.push(...n.entries);while((n=n.context)&&n.entries);let o=[],h=(c,l=s)=>{let{callback:d,options:f,origins:b,dispose:_}=c,u=e.length-1;for(;u>=(f.scope||0);u--)if(b[u]!==e[u])return;o.push(d({...l,path:t,scope:u+1,origins:e,timestamp:r})),f.once&&_()};if(a.forEach(c=>h(c)),s.type==="clear"||s.type==="patch"){let c=this._path(t,!1);for(let[l,d]of c?.subtree.entries()||[]){let f={type:"delete",key:l,detail:s.detail};if(s.type==="patch"&&s.data&&typeof s.data=="object"){if(l in s.data)f={type:"set",key:l,value:s.data[l],detail:s.detail};else if(!s.replace)continue}for(let b of d.entries)h(b,f)}}this.#i&&o.push(this.#i({path:t,origins:e,timestamp:r,...s})),await Promise.all(o)}_normalizeExpires(t){if(t??!1){if(t instanceof Date)return t.getTime();if(typeof t=="number")return t<1e12?t*1e3:t;if(typeof t=="string"){let e=Date.parse(t);if(!Number.isNaN(e))return e}throw new TypeError(`Invalid expires value: ${t}`)}}_expired(t){return!this.hasTTL||!this.fieldLevelExpiry?!1:!!(t?.expires&&t.expires<=Date.now())}_resolveSet(t,e,r){let s=typeof t=="object"&&t,i;({key:t,value:e,...i}=s?t:{key:t,value:e}),this.hasTTL&&this.fieldLevelExpiry&&(i.expires?i.expires=this._normalizeExpires(i.expires):i.expires=Date.now()+this.ttl);let a={type:"set",key:t,value:e,path:this.path,detail:r?.detail,origins:this.origins,timestamp:Date.now()};return{key:t,value:e,rest:i,event:a}}_resolveInputPatch(t,e){if(typeof t!="object")throw new Error("Argument must be a valid JSON object");let r=this.hasTTL&&this.fieldLevelExpiry?Date.now()+this.ttl:null,s={},i={};for(let[n,o]of Object.entries(t)){if(e.meta&&!(o&&typeof o=="object"))throw new Error(`A hash expected for field ${n}`);s[n]=e.meta?o.value:o,i[n]=e.meta?o:{value:o},r&&!i[n].expires?i[n].expires=r:this.hasTTL&&this.fieldLevelExpiry&&i[n].expires&&(i[n].expires=this._normalizeExpires(i[n].expires))}let a={type:"patch",data:s,meta:!!e?.meta,replace:!!e?.replace,detail:e?.detail,path:this.path,origins:this.origins,timestamp:Date.now()};return{data:i,event:a}}_resolveDelete(t,e){t=typeof t=="object"&&t?t.key:t;let r={type:"delete",key:t,path:this.path,detail:e?.detail,origins:this.origins,timestamp:Date.now()};return{key:t,event:r}}_resolveClear(t){return{event:{type:"clear",path:this.path,detail:t?.detail,origins:this.origins,timestamp:Date.now()}}}observe(t,e,r={}){typeof t=="function"&&(r=e||{},e=t,t=[]);let s=this.#t.concat(t);return this._observe(s,e,r)}cleanup(){this._path(this.#t,!1)?.dispose()}async close(){}};var w=class extends p{#t(t){if(!t?.subtree.has("value"))return;let e=t.subtree.get("expires");if(e&&e<=Date.now()){this.#e(t);return}return t}#e(t){t&&!t.entries.size?t.dispose():t?.subtree.clear()}async close(){}async count(){return(await this.keys()).length}async keys(){return(await this.#s()).map(([t])=>t)}async values(){return(await this.#s()).map(([,t])=>t)}async entries(){return await this.#s()}async json({meta:t=!1}={}){return Object.fromEntries(await this.#s({meta:t}))}async#s({meta:t=!1}={}){return[...this._path(this.path)?.subtree.entries()||[]].filter(([,e])=>this.#t(e)).map(([e,r])=>[e,t?Object.fromEntries(r.subtree):r.subtree.get("value")])}async has(t){t=typeof t=="object"&&t?t.key:t;let e=this.path.concat(t);return!!this.#t(this._path(e,!1))}async get(t){let e=typeof t=="object"&&t;t=e?t.key:t;let r=this.path.concat(t),s=this.#t(this._path(r,!1));if(s)return e?Object.fromEntries(s.subtree):s.subtree.get("value")}async set(t,e,r={}){let s,i;({key:t,value:e,rest:s,event:i}=this._resolveSet(t,e,r));let a=this.path.concat(t),n=this._path(a);n.subtree.set("value",e),Object.entries(s).forEach(([o,h])=>n.subtree.set(o,h)),await this._fire(i)}async patch(t=null,e={}){let{data:r,event:s}=this._resolveInputPatch(t,e);if(e.replace)for(let i of this._path(this.path,!1)?.subtree.values()||[])this.#e(i);for(let[i,a]of Object.entries(r)){let n=this.path.concat(i),o=this._path(n);Object.entries(a).forEach(([h,c])=>o.subtree.set(h,c))}await this._fire(s)}async delete(t,e={}){let r;({key:t,event:r}=this._resolveDelete(t,e));let s=this.path.concat(t),i=this._path(s,!1);this.#e(i),await this._fire(r)}async clear(t={}){let{event:e}=this._resolveClear(t);for(let r of this._path(this.path,!1)?.subtree.values()||[])this.#e(r);await this._fire(e)}};})();
//# sourceMappingURL=inmemory.js.map
