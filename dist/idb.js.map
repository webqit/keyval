{
  "version": 3,
  "sources": ["../src/Store.js", "../src/IDBStore.js"],
  "sourcesContent": ["export class Store {\n\n    static create(options) { return new this(options); }\n\n    #path;\n    #ttl;\n    #registry;\n    #origins;\n\n    get path() { return this.#path; }\n    get ttl() { return this.#ttl; }\n    get registry() { return this.#registry; }\n    get origins() { return this.#origins; }\n\n    constructor({ path, ttl = 0, registry = new Map, origins = [] } = {}) {\n        this.#path = path;\n        this.#ttl = ttl;\n        this.#registry = registry;\n        this.#origins = origins;\n    }\n\n    _path(path, create = true) {\n        if (!Array.isArray(path) || !path.length || path.length > this.#path.length + 1) {\n            throw new Error(`Path length must be between 1 and ${this.#path.length + 1}`);\n        }\n        /*\n        base -> {\n            subtree: uuid -> {\n                    subtree: field -> {\n                            subtree,\n                            entries: Set<fn>\n                        },\n                    entries: Set<fn>\n                },\n            entries: Set<fn>\n        }\n        */\n        return path.reduce((node, key, i) => {\n            if (create === 0 && i && !node.subtree.has(key)) {\n                return node;\n            }\n            if (create && !node.subtree.has(key)) {\n                const subtree = new Map;\n                const entries = new Set;\n                const dispose = () => {\n                    node.subtree.delete(key);\n                    if (!node.subtree.size && !node.entries?.size) {\n                        //node.dispose?.();\n                    }\n                };\n                node.subtree.set(key, { subtree, entries, context: node, dispose });\n            }\n            return node?.subtree.get(key);\n        }, { subtree: this.#registry });\n    }\n\n    _observe(path, callback, options = {}) {\n        const node = this._path(path, true);\n\n        const dispose = () => {\n            node.entries.delete(subscription);\n            if (!node.entries.size) {\n                node.dispose();\n            }\n        };\n\n        const subscription = { callback, options, origins: this.#origins, dispose };\n        node.entries.add(subscription);\n\n        if (options.signal) {\n            options.signal.addEventListener('abort', dispose);\n        }\n\n        return dispose;\n    }\n\n    async _fire({ path = this.#path, origins = this.#origins, timestamp = Date.now(), ...event }) {\n        if (!['set', 'delete', 'clear', 'json'].includes(event.type)) {\n            throw new Error(`Invalid event`);\n        }\n        const node = this._path(event.key ? path.concat(event.key) : path, 0);\n        if (!node) return;\n\n        const entries = [];\n        let _node = node;\n        do {\n            entries.push(..._node.entries);\n        } while ((_node = _node.context) && _node.entries);\n\n        const returnValues = [];\n        const fire = (subscription, _event = event) => {\n            const { callback, options, origins: subscriptionOrigins, dispose } = subscription;\n\n            let i = this.#origins.length - 1;\n            for (; i >= (options.scope || 0); i--) {\n                if (subscriptionOrigins[i] !== this.#origins[i]) return;\n            }\n\n            returnValues.push(callback({ ..._event, path, scope: i + 1, origins, timestamp }));\n\n            if (options.once) dispose();\n        };\n\n        entries.forEach((subscription) => fire(subscription));\n\n        if (event.type === 'clear' || event.type === 'json') {\n            const node = this._path(path, false);\n            for (const [key, _node] of node?.subtree.entries() || []) {\n\n                let _event = { type: 'delete', key };\n                if (event.type === 'json' && event.data && typeof event.data === 'object') {\n                    if (key in event.data) {\n                        _event = { type: 'set', key, value: event.data[key] };\n                    } else if (event.options?.merge) {\n                        continue;\n                    }\n                }\n\n                for (const subscription of _node.entries) {\n                    fire(subscription, _event);\n                }\n            }\n        }\n\n        await Promise.all(returnValues);\n    }\n\n    // ----------\n\n    observe(key, callback, options = {}) {\n        if (typeof key === 'function') {\n            options = callback || {};\n            callback = key;\n            key = [];\n        }\n        const fieldPath = this.#path.concat(key);\n        return this._observe(fieldPath, callback, options);\n    }\n\n    cleanup() { this._path(this.#path, false)?.dispose(); }\n\n    async close() { }\n}", "import { Store } from './Store.js';\nexport { Store };\n\nexport class IDBStore extends Store {\n\n    static #dbCache = new Map;\n\n    #db;\n    #dbName;\n    #storeName;\n    #channel;\n\n    constructor({ dbName = 'webqit_store', channel = null, ...options }) {\n        super(options);\n        this.#dbName = dbName;\n        this.#storeName = this.path.join(':');\n        if (channel) {\n            this.#channel = new BroadcastChannel(channel);\n        }\n    }\n\n    /* ---------- internal helpers ---------- */\n\n    #attachDBLifecycle(db) {\n        db.onversionchange = () => {\n            // Another tab wants to upgrade the DB\n            db.close();\n\n            // Invalidate local handle so next op reopens\n            IDBStore.#dbCache.delete(this.#dbName);\n\n            this.#db = null;\n        };\n    }\n\n    async #open() {\n        const cacheKey = this.#dbName;\n\n        if (IDBStore.#dbCache.has(cacheKey)) {\n            this.#db = IDBStore.#dbCache.get(cacheKey);\n            if (this.#db.objectStoreNames.contains(this.#storeName)) {\n                return this.#db;\n            }\n            // store missing \u2192 upgrade required\n        }\n\n        const openWithUpgrade = async (version) => {\n            return new Promise((resolve, reject) => {\n                const req = indexedDB.open(this.#dbName, version);\n\n                req.onupgradeneeded = () => {\n                    const db = req.result;\n                    if (!db.objectStoreNames.contains(this.#storeName)) {\n                        db.createObjectStore(this.#storeName);\n                    }\n                };\n\n                req.onsuccess = () => resolve(req.result);\n                req.onerror = () => reject(req.error);\n            });\n        };\n\n        // First open: get current version\n        const initialDB = await new Promise((resolve, reject) => {\n            const req = indexedDB.open(this.#dbName);\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = () => reject(req.error);\n        });\n\n        if (!initialDB.objectStoreNames.contains(this.#storeName)) {\n            const nextVersion = initialDB.version + 1;\n            initialDB.close();\n            this.#db = await openWithUpgrade(nextVersion);\n        } else {\n            this.#db = initialDB;\n        }\n\n        IDBStore.#dbCache.set(cacheKey, this.#db);\n        this.#attachDBLifecycle(this.#db);\n        return this.#db;\n    }\n\n    #tx(mode = 'readonly') {\n        return this.#db\n            .transaction(this.#storeName, mode)\n            .objectStore(this.#storeName);\n    }\n\n    #isExpired(node) {\n        return node?.expiresAt && node.expiresAt <= Date.now();\n    }\n\n    #wrapValue(value) {\n        return {\n            value,\n            expiresAt: this.ttl ? Date.now() + this.ttl * 1000 : null,\n        };\n    }\n\n    /* ---------- public API ---------- */\n\n    async close() {\n        this.#channel?.close();\n        this.#db?.close();\n\n        IDBStore.#dbCache.delete(this.#dbName);\n        this.#db = null;\n\n        await super.close();\n    }\n\n    async keys() {\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const req = this.#tx().getAllKeys();\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = () => reject(req.error);\n        });\n    }\n\n    async values() {\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const req = this.#tx().getAll();\n            req.onsuccess = () => {\n                resolve(\n                    req.result\n                        .filter((e) => !this.#isExpired(e))\n                        .map((e) => e.value)\n                );\n            };\n            req.onerror = () => reject(req.error);\n        });\n    }\n\n    async entries() { return await this.#entries(); }\n\n    async #entries(dump = false) {\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readonly');\n            const store = tx.objectStore(this.#storeName);\n\n            const valuesReq = store.getAll();\n            const keysReq = store.getAllKeys();\n\n            let values, keys;\n\n            valuesReq.onsuccess = () => { values = valuesReq.result; };\n            keysReq.onsuccess = () => { keys = keysReq.result; };\n\n            tx.oncomplete = () => {\n                resolve(\n                    keys\n                        .map((k, i) => [k, values[i]])\n                        .filter(([, e]) => !this.#isExpired(e))\n                        .map(([k, e]) => [k, dump ? e : e.value])\n                );\n            };\n\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n\n    async count() {\n        const entries = await this.entries();\n        return entries.length;\n    }\n\n    async has(key) {\n        const v = await this.get(key);\n        return v !== undefined;\n    }\n\n    async get(key) {\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const req = this.#tx().get(key);\n            req.onsuccess = async () => {\n                const node = req.result;\n                if (!node || this.#isExpired(node)) {\n                    if (node) await this.delete(key);\n                    resolve(undefined);\n                } else {\n                    resolve(node.value);\n                }\n            };\n            req.onerror = () => reject(req.error);\n        });\n    }\n\n    async set(key, value) {\n        const event = {\n            type: 'set',\n            key,\n            value,\n            path: this.path,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readwrite');\n            tx.objectStore(this.#storeName)\n                .put(this.#wrapValue(value), key);\n\n            tx.oncomplete = async () => {\n                await this._fire(event);\n                this.#channel?.postMessage(event);\n                resolve();\n            };\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n\n    async delete(key) {\n        const event = {\n            type: 'delete',\n            key,\n            path: this.path,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readwrite');\n            tx.objectStore(this.#storeName).delete(key);\n\n            tx.oncomplete = async () => {\n                await this._fire(event);\n                this.#channel?.postMessage(event);\n                resolve();\n            };\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n\n    async clear() {\n        const event = {\n            type: 'clear',\n            path: this.path,\n            origins: this.origins,\n            timestamp: Date.now(),\n        };\n\n        await this.#open();\n        return new Promise((resolve, reject) => {\n            const tx = this.#db.transaction(this.#storeName, 'readwrite');\n            tx.objectStore(this.#storeName).clear();\n\n            tx.oncomplete = async () => {\n                await this._fire(event);\n                this.#channel?.postMessage(event);\n                resolve();\n            };\n            tx.onerror = () => reject(tx.error);\n        });\n    }\n\n    async json(arg = null, options = {}) {\n        if (arg && arg !== true) {\n            if (typeof arg !== 'object') {\n                throw new Error(`Argument must be a valid JSON object`);\n            }\n\n            const unhashed = {};\n            const data = {};\n            for (const [key, value] of Object.entries(arg)) {\n                if (options.hashed && !(value && typeof value === 'object')) {\n                    throw new Error(`A hash expected for field ${key}`);\n                }\n                unhashed[key] = options.hashed ? value.value : value;\n                data[key] = options.hashed\n                    ? { ...value, ...this.#wrapValue(value.value) }\n                    : this.#wrapValue(value);\n            }\n\n            const event = {\n                type: 'json',\n                data: unhashed,\n                options,\n                path: this.path,\n                origins: this.origins,\n                timestamp: Date.now(),\n            };\n\n            await this.#open();\n            return new Promise((resolve, reject) => {\n                const tx = this.#db.transaction(this.#storeName, 'readwrite');\n\n                const store = tx.objectStore(this.#storeName);\n                if (!options.merge) {\n                    store.clear();\n                }\n                for (const [key, value] of Object.entries(data)) {\n                    store.put(value, key);\n                }\n\n                tx.oncomplete = async () => {\n                    await this._fire(event);\n                    this.#channel?.postMessage(event);\n                    resolve();\n                };\n                tx.onerror = () => reject(tx.error);\n            });\n        }\n\n        return Object.fromEntries(await this.#entries(arg));\n    }\n}\n"],
  "mappings": "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",
  "names": ["Store", "options", "#path", "#ttl", "#registry", "#origins", "path", "ttl", "registry", "origins", "create", "node", "key", "subtree", "entries", "dispose", "callback", "subscription", "timestamp", "event", "_node", "returnValues", "fire", "_event", "subscriptionOrigins", "i", "fieldPath", "IDBStore", "_IDBStore", "Store", "#dbCache", "#db", "#dbName", "#storeName", "#channel", "dbName", "channel", "options", "#attachDBLifecycle", "db", "#open", "cacheKey", "openWithUpgrade", "version", "resolve", "reject", "req", "initialDB", "nextVersion", "#tx", "mode", "#isExpired", "node", "#wrapValue", "value", "#entries", "dump", "tx", "store", "valuesReq", "keysReq", "values", "keys", "k", "i", "e", "key", "event", "arg", "unhashed", "data"]
}
