(()=>{var p=class{static create(t){return new this(t)}#t;#s;#e;#r;#i;get path(){return this.#t}get ttl(){return this.#s}get registry(){return this.#e}get origins(){return this.#r}get options(){return this.#i}get keyLevelExpires(){return!0}constructor({path:t,ttl:e=0,registry:r=new Map,origins:s=[],...i}={}){this.#t=t,this.#s=e,this.#e=r,this.#r=s,this.#i=i}_path(t,e=!0){if(!Array.isArray(t)||!t.length)throw new Error("Path length cannot be 0");return t.reduce((r,s,i)=>{if(e&&!r?.subtree.has(s)){let o=new Map,n=new Set,a=()=>{r.subtree.delete(s),!r.subtree.size&&r.entries?.size};r.subtree.set(s,{subtree:o,entries:n,context:r,dispose:a})}return e===0&&i&&!r?.subtree.has(s)?r:r?.subtree.get(s)},{subtree:this.#e})}_observe(t,e,r={}){let s=this._path(t,!0),i=()=>{s.entries.delete(o),s.entries.size||s.dispose()},o={callback:e,options:r,origins:this.#r,dispose:i};return s.entries.add(o),r.signal&&r.signal.addEventListener("abort",i),i}async _fire({path:t=this.#t,origins:e=this.#r,timestamp:r=Date.now(),...s}){if(!["set","delete","clear","json"].includes(s.type))throw new Error("Invalid event");let i=this._path(s.key?t.concat(s.key):t,0);if(!i)return;let o=[],n=i;do o.push(...n.entries);while((n=n.context)&&n.entries);let a=[],l=(h,c=s)=>{let{callback:b,options:u,origins:d,dispose:g}=h,f=e.length-1;for(;f>=(u.scope||0);f--)if(d[f]!==e[f])return;a.push(b({...c,path:t,scope:f+1,origins:e,timestamp:r})),u.once&&g()};if(o.forEach(h=>l(h)),s.type==="clear"||s.type==="json"){let h=this._path(t,!1);for(let[c,b]of h?.subtree.entries()||[]){let u={type:"delete",key:c};if(s.type==="json"&&s.data&&typeof s.data=="object"){if(c in s.data)u={type:"set",key:c,value:s.data[c]};else if(s.options?.merge)continue}for(let d of b.entries)l(d,u)}}await Promise.all(a)}_normalizeExpires(t){if(t??!1){if(t instanceof Date)return t.getTime();if(typeof t=="number")return t<1e12?t*1e3:t;if(typeof t=="string"){let e=Date.parse(t);if(!Number.isNaN(e))return e}throw new TypeError(`Invalid expires value: ${t}`)}}_expired(t){return!this.ttl||!this.keyLevelExpires?!1:!!(t?.expires&&t.expires<=Date.now())}_resolveSet(t,e){let r=typeof t=="object"&&t,s;({key:t,value:e,...s}=r?t:{key:t,value:e}),this.ttl&&this.keyLevelExpires&&(s.expires?s.expires=this._normalizeExpires(s.expires):s.expires=Date.now()+this.ttl);let i={type:"set",key:t,value:e,path:this.path,origins:this.origins,timestamp:Date.now()};return{key:t,value:e,rest:s,event:i}}_resolveInputJson(t,e){if(typeof t!="object")throw new Error("Argument must be a valid JSON object");let r=this.ttl&&this.keyLevelExpires?Date.now()+this.ttl:null,s={},i={};for(let[n,a]of Object.entries(t)){if(e.hashed&&!(a&&typeof a=="object"))throw new Error(`A hash expected for field ${n}`);s[n]=e.hashed?a.value:a,i[n]=e.hashed?a:{value:a},r&&!i[n].expires?i[n].expires=r:this.ttl&&this.keyLevelExpires&&i[n].expires&&(i[n].expires=this._normalizeExpires(i[n].expires))}let o={type:"json",data:s,options:e,path:this.path,origins:this.origins,timestamp:Date.now()};return{data:i,event:o}}observe(t,e,r={}){typeof t=="function"&&(r=e||{},e=t,t=[]);let s=this.#t.concat(t);return this._observe(s,e,r)}cleanup(){this._path(this.#t,!1)?.dispose()}async close(){}};var w=class extends p{#t(t){if(!t?.subtree.has("value"))return;let e=t.subtree.get("expires");if(e&&e<=Date.now()){this.#s(t);return}return t}#s(t){t&&!t.entries.size?t.dispose():t?.subtree.clear()}async close(){}async count(){return(await this.keys()).length}async keys(){return(await this.#e()).map(([t])=>t)}async values(){return(await this.#e()).map(([,t])=>t)}async entries(){return await this.#e()}async#e(t=!1){return[...this._path(this.path)?.subtree.entries()||[]].filter(([,e])=>this.#t(e)).map(([e,r])=>[e,t?Object.fromEntries(r.subtree):r.subtree.get("value")])}async has(t){t=typeof t=="object"&&t?t.key:t;let e=this.path.concat(t);return!!this.#t(this._path(e,!1))}async get(t){let e=typeof t=="object"&&t;t=e?t.key:t;let r=this.path.concat(t),s=this._path(r,!1);return e?Object.fromEntries(s.subtree):this.#t(s)?.subtree.get("value")}async set(t,e){let r,s;({key:t,value:e,rest:r,event:s}=this._resolveSet(t,e));let i=this.path.concat(t),o=this._path(i);o.subtree.set("value",e),Object.entries(r).forEach(([n,a])=>o.subtree.set(n,a)),await this._fire(s)}async delete(t){t=typeof t=="object"&&t?t.key:t;let e={type:"delete",key:t},r=this.path.concat(t),s=this._path(r,!1);this.#s(s),await this._fire(e)}async clear(){let t={type:"clear"};for(let e of this._path(this.path,!1)?.subtree.values()||[])this.#s(e);await this._fire(t)}async json(t=null,e={}){if(t&&t!==!0){let{data:r,event:s}=this._resolveInputJson(t,e);if(!e.merge)for(let i of this._path(this.path,!1)?.subtree.values()||[])this.#s(i);for(let[i,o]of Object.entries(r)){let n=this.path.concat(i),a=this._path(n);Object.entries(o).forEach(([l,h])=>a.subtree.set(l,h))}await this._fire(s);return}return Object.fromEntries(await this.#e(t))}};})();
//# sourceMappingURL=main.js.map
