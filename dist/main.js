(()=>{var u=class{static create(t){return new this(t)}#t;#s;#e;get path(){return this.#t}get registry(){return this.#s}get origins(){return this.#e}constructor({path:t,registry:e=new Map,origins:s=[]}={}){this.#t=t,this.#s=e,this.#e=s}_path(t,e=!0){if(!Array.isArray(t)||!t.length||t.length>this.#t.length+1)throw new Error(`Path length must be between 1 and ${this.#t.length+1}`);return t.reduce((s,r,i)=>{if(e===0&&i&&!s.subtree.has(r))return s;if(e&&!s.subtree.has(r)){let n=new Map,a=new Set,c=()=>s.subtree.delete(r);s.subtree.set(r,{subtree:n,entries:a,context:s,dispose:c})}return s?.subtree.get(r)},{subtree:this.#s})}_observe(t,e,s={}){let r=this._path(t,!0),i=()=>{r.entries.delete(n),r.entries.size||r.dispose()},n={callback:e,options:s,origins:this.#e,dispose:i};return r.entries.add(n),s.signal&&s.signal.addEventListener("abort",i),i}async _fire({path:t=this.#t,origins:e=this.#e,timestamp:s=Date.now(),...r}){if(!["set","delete","clear"].includes(r.type))throw new Error("Invalid event");let i=this._path(t,0);if(!i)return;let n=[],a=i;for(;a;)n.push(...a.entries),a=a.context;let c=[],b=(l,p=t)=>{let{callback:f,options:o,origins:_,dispose:w}=l,h=this.#e.length-1;for(;h>=(o.scope||0);h--)if(_[h]!==this.#e[h])return;c.push(f({...r,path:p,scope:h+1,origins:e,timestamp:s})),o.once&&w()};if(n.forEach(b),r.type==="clear"){let l=this._path(t,!1);for(let[p,f]of l?.subtree.entries()||[])for(let o of f.entries)b(o,t.concat(p))}await Promise.all(c)}observe(t,e,s={}){typeof t=="function"&&(s=e||{},e=t,t=[]);let r=this.#t.concat(t);return this._observe(r,e,s)}cleanup(){this._path(this.#t,!1)?.dispose()}};var d=class extends u{async keys(){return[...this._path(this.path)?.subtree.keys()||[]]}async values(){return[...this._path(this.path)?.subtree.values()||[]].map(t=>t.subtree.get("value"))}async entries(){return[...this._path(this.path)?.subtree.entries()||[]].map(([t,e])=>[t,e.subtree.get("value")])}async count(){return this.keys().then(t=>t.length)}async has(t){let e=this.path.concat(t);return!!this._path(e,!1)?.subtree.has("value")}async get(t){let e=this.path.concat(t);return this._path(e,!1)?.subtree.get("value")}async getHash(t){let e=this.path.concat(t);return Object.fromEntries(this._path(e,!1)?.subtree)}async set(t,e){let s={type:"set",key:t,value:e},r=this.path.concat(t);this._path(r).subtree.set("value",e),await this._fire(s)}async setHash(t,{value:e,...s}={}){let r=this.path.concat(t),i=this._path(r).subtree;for(let n in s)i.set(n,s[n]);return await this.set(t,e)}async delete(t){let e={type:"delete",key:t},s=this.path.concat(t);this._path(s).subtree.clear(),await this._fire(e)}async clear(){let t={type:"clear"};for(let e of this._path(this.path)?.subtree.values()||[])e.subtree.clear();await this._fire(t)}};})();
//# sourceMappingURL=main.js.map
