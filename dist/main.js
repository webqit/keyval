(()=>{var p=class{static create(t){return new this(t)}#t;#e;#s;#i;get path(){return this.#t}get ttl(){return this.#e}get registry(){return this.#s}get origins(){return this.#i}constructor({path:t,ttl:e=0,registry:i=new Map,origins:s=[]}={}){this.#t=t,this.#e=e,this.#s=i,this.#i=s}_path(t,e=!0){if(!Array.isArray(t)||!t.length||t.length>this.#t.length+1)throw new Error(`Path length must be between 1 and ${this.#t.length+1}`);return t.reduce((i,s,r)=>{if(e===0&&r&&!i.subtree.has(s))return i;if(e&&!i.subtree.has(s)){let h=new Map,n=new Set,a=()=>{i.subtree.delete(s),!i.subtree.size&&i.entries?.size};i.subtree.set(s,{subtree:h,entries:n,context:i,dispose:a})}return i?.subtree.get(s)},{subtree:this.#s})}_observe(t,e,i={}){let s=this._path(t,!0),r=()=>{s.entries.delete(h),s.entries.size||s.dispose()},h={callback:e,options:i,origins:this.#i,dispose:r};return s.entries.add(h),i.signal&&i.signal.addEventListener("abort",r),r}async _fire({path:t=this.#t,origins:e=this.#i,timestamp:i=Date.now(),...s}){if(!["set","delete","clear","json"].includes(s.type))throw new Error("Invalid event");let r=this._path(s.key?t.concat(s.key):t,0);if(!r)return;let h=[],n=r;do h.push(...n.entries);while((n=n.context)&&n.entries);let a=[],f=(o,c=s)=>{let{callback:b,options:u,origins:d,dispose:w}=o,l=this.#i.length-1;for(;l>=(u.scope||0);l--)if(d[l]!==this.#i[l])return;a.push(b({...c,path:t,scope:l+1,origins:e,timestamp:i})),u.once&&w()};if(h.forEach(o=>f(o)),s.type==="clear"||s.type==="json"){let o=this._path(t,!1);for(let[c,b]of o?.subtree.entries()||[]){let u={type:"delete",key:c};if(s.type==="json"&&s.data&&typeof s.data=="object"){if(c in s.data)u={type:"set",key:c,value:s.data[c]};else if(s.options?.merge)continue}for(let d of b.entries)f(d,u)}}await Promise.all(a)}observe(t,e,i={}){typeof t=="function"&&(i=e||{},e=t,t=[]);let s=this.#t.concat(t);return this._observe(s,e,i)}cleanup(){this._path(this.#t,!1)?.dispose()}async close(){}};var y=class extends p{#t(t){if(!t?.subtree.has("value"))return;let e=t.subtree.get("expiresAt");if(e&&e<=Date.now()){this.#e(t);return}return t}#e(t){t&&!t.entries.size?t.dispose():t?.subtree.clear()}async keys(){return[...this._path(this.path)?.subtree.entries()||[]].filter(([,t])=>this.#t(t)).map(([t])=>t)}async values(){return[...this._path(this.path)?.subtree.values()||[]].filter(t=>this.#t(t)).map(t=>t.subtree.get("value"))}async entries(){return await this.#s()}async#s(t=!1){return[...this._path(this.path)?.subtree.entries()||[]].filter(([,e])=>this.#t(e)).map(([e,i])=>[e,t?Object.fromEntries(i.subtree):i.subtree.get("value")])}async count(){return this.keys().then(t=>t.length)}async has(t){let e=this.path.concat(t);return!!this.#t(this._path(e,!1))}async get(t){let e=this.path.concat(t),i=this._path(e,!1);return this.#t(i)?.subtree.get("value")}async set(t,e){let i={type:"set",key:t,value:e},s=this.path.concat(t),r=this._path(s);r.subtree.set("value",e),this.ttl&&r.subtree.set("expiresAt",Date.now()+this.ttl*1e3),await this._fire(i)}async delete(t){let e={type:"delete",key:t},i=this.path.concat(t),s=this._path(i,!1);this.#e(s),await this._fire(e)}async clear(){let t={type:"clear"};for(let e of this._path(this.path,!1)?.subtree.values()||[])this.#e(e);await this._fire(t)}async json(t=null,e={}){if(t&&t!==!0){if(typeof t!="object")throw new Error("Argument must be a valid JSON object");let i=this.ttl?Date.now()+this.ttl*1e3:null,s={},r={};for(let[n,a]of Object.entries(t)){if(e.hashed&&!(a&&typeof a=="object"))throw new Error(`A hash expected for field ${n}`);s[n]=e.hashed?a.value:a,r[n]=e.hashed?{value:void 0,...a,expiresAt:i}:{value:a,expiresAt:i}}let h={type:"json",data:s,options:e,path:this.path,origins:this.origins,timestamp:Date.now()};if(!e.merge)for(let n of this._path(this.path,!1)?.subtree.values()||[])this.#e(n);for(let[n,a]of Object.entries(r)){let f=this.path.concat(n),o=this._path(f);o.subtree=new Map(Object.entries(a))}await this._fire(h);return}return Object.fromEntries(await this.#s(t))}};})();
//# sourceMappingURL=main.js.map
