(()=>{var u=class{static create(t){return new this(t)}#t;#r;#s;#e;get path(){return this.#t}get ttl(){return this.#r}get registry(){return this.#s}get origins(){return this.#e}constructor({path:t,ttl:e=0,registry:s=new Map,origins:r=[]}={}){this.#t=t,this.#r=e,this.#s=s,this.#e=r}_path(t,e=!0){if(!Array.isArray(t)||!t.length||t.length>this.#t.length+1)throw new Error(`Path length must be between 1 and ${this.#t.length+1}`);return t.reduce((s,r,i)=>{if(e===0&&i&&!s.subtree.has(r))return s;if(e&&!s.subtree.has(r)){let n=new Map,a=new Set,c=()=>s.subtree.delete(r);s.subtree.set(r,{subtree:n,entries:a,context:s,dispose:c})}return s?.subtree.get(r)},{subtree:this.#s})}_observe(t,e,s={}){let r=this._path(t,!0),i=()=>{r.entries.delete(n),r.entries.size||r.dispose()},n={callback:e,options:s,origins:this.#e,dispose:i};return r.entries.add(n),s.signal&&s.signal.addEventListener("abort",i),i}async _fire({path:t=this.#t,origins:e=this.#e,timestamp:s=Date.now(),...r}){if(!["set","delete","clear"].includes(r.type))throw new Error("Invalid event");let i=this._path(t,0);if(!i)return;let n=[],a=i;do n.push(...a.entries);while((a=a.context)&&a.entries);let c=[],b=(l,f=t)=>{let{callback:p,options:o,origins:_,dispose:w}=l,h=this.#e.length-1;for(;h>=(o.scope||0);h--)if(_[h]!==this.#e[h])return;c.push(p({...r,path:f,scope:h+1,origins:e,timestamp:s})),o.once&&w()};if(n.forEach(b),r.type==="clear"){let l=this._path(t,!1);for(let[f,p]of l?.subtree.entries()||[])for(let o of p.entries)b(o,t.concat(f))}await Promise.all(c)}observe(t,e,s={}){typeof t=="function"&&(s=e||{},e=t,t=[]);let r=this.#t.concat(t);return this._observe(r,e,s)}cleanup(){this._path(this.#t,!1)?.dispose()}async close(){}};var d=class extends u{#t(t){if(!t?.subtree.has("value"))return;let e=t.subtree.get("expiresAt");if(e&&e<=Date.now()){t.subtree.clear();return}return t}async keys(){return[...this._path(this.path)?.subtree.entries()||[]].filter(([,t])=>this.#t(t)).map(([t])=>t)}async values(){return[...this._path(this.path)?.subtree.values()||[]].filter(t=>this.#t(t)).map(t=>t.subtree.get("value"))}async entries(){return[...this._path(this.path)?.subtree.entries()||[]].filter(([,t])=>this.#t(t)).map(([t,e])=>[t,e.subtree.get("value")])}async count(){return this.keys().then(t=>t.length)}async has(t){let e=this.path.concat(t);return!!this.#t(this._path(e,!1))}async get(t){let e=this.path.concat(t),s=this._path(e,!1);return this.#t(s)?.subtree.get("value")}async getHash(t){let e=this.path.concat(t),s=this._path(e,!1);return Object.fromEntries(this.#t(s)?.subtree||[])}async set(t,e){let s={type:"set",key:t,value:e},r=this.path.concat(t),i=this._path(r);i.subtree.set("value",e),this.ttl&&i.subtree.set("expiresAt",Date.now()+this.ttl*1e3),await this._fire(s)}async setHash(t,{value:e,...s}={}){let r=this.path.concat(t),i=this._path(r);for(let n in s)i.subtree.set(n,s[n]);return await this.set(t,e)}async delete(t){let e={type:"delete",key:t},s=this.path.concat(t);this._path(s,!1)?.subtree.clear(),await this._fire(e)}async clear(){let t={type:"clear"};for(let e of this._path(this.path,!1)?.subtree.values()||[])e.subtree.clear();await this._fire(t)}};})();
//# sourceMappingURL=main.js.map
